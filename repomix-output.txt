This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-27T18:29:49.955Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
BEAUTIFY_QUERY.API/BEAUTIFY_QUERY.API.csproj
BEAUTIFY_QUERY.API/DependencyInjection/Extensions/JwtExtensions.cs
BEAUTIFY_QUERY.API/Dockerfile
BEAUTIFY_QUERY.API/Middlewares/ExceptionHandlingMiddleware.cs
BEAUTIFY_QUERY.API/Program.cs
BEAUTIFY_QUERY.API/Properties/launchSettings.json
BEAUTIFY_QUERY.APPLICATION.Tests/BEAUTIFY_QUERY.APPLICATION.Tests.csproj
BEAUTIFY_QUERY.APPLICATION.Tests/UseCases/Queries/Orders/GetClinicOrderBranchesQueryHandlerTests.cs
BEAUTIFY_QUERY.APPLICATION.Tests/UseCases/Queries/Orders/GetOrdersByCustomerIdQueryHandlerTests.cs
BEAUTIFY_QUERY.APPLICATION/AssemblyReference.cs
BEAUTIFY_QUERY.APPLICATION/BEAUTIFY_QUERY.APPLICATION.csproj
BEAUTIFY_QUERY.APPLICATION/DependencyInjection/Extensions/AddMediatRApplication.cs
BEAUTIFY_QUERY.APPLICATION/Exceptions/ValidationException.cs
BEAUTIFY_QUERY.APPLICATION/GlobalUsings.cs
BEAUTIFY_QUERY.APPLICATION/Mapper/ServiceProfile.cs
BEAUTIFY_QUERY.APPLICATION/UseCases/PostgreMigrate/PostgreMigrateEventHandler.cs
BEAUTIFY_QUERY.CONTRACT/AssemblyReference.cs
BEAUTIFY_QUERY.CONTRACT/BEAUTIFY_QUERY.CONTRACT.csproj
BEAUTIFY_QUERY.CONTRACT/GlobalUsings.cs
BEAUTIFY_QUERY.CONTRACT/Services/Booking/Query.cs
BEAUTIFY_QUERY.CONTRACT/Services/Booking/Response.cs
BEAUTIFY_QUERY.CONTRACT/Services/Categories/Query.cs
BEAUTIFY_QUERY.CONTRACT/Services/Categories/Response.cs
BEAUTIFY_QUERY.CONTRACT/Services/Clinics/Query.cs
BEAUTIFY_QUERY.CONTRACT/Services/Clinics/Response.cs
BEAUTIFY_QUERY.CONTRACT/Services/CustomerSchedules/Query.cs
BEAUTIFY_QUERY.CONTRACT/Services/CustomerSchedules/Response.cs
BEAUTIFY_QUERY.CONTRACT/Services/Dashboards/Query.cs
BEAUTIFY_QUERY.CONTRACT/Services/Dashboards/Response.cs
BEAUTIFY_QUERY.CONTRACT/Services/DoctorCertificates/Query.cs
BEAUTIFY_QUERY.CONTRACT/Services/DoctorCertificates/Response.cs
BEAUTIFY_QUERY.CONTRACT/Services/OrderDetails/Query.cs
BEAUTIFY_QUERY.CONTRACT/Services/OrderDetails/Response.cs
BEAUTIFY_QUERY.CONTRACT/Services/Orders/Query.cs
BEAUTIFY_QUERY.CONTRACT/Services/Orders/Response.cs
BEAUTIFY_QUERY.CONTRACT/Services/Services/Query.cs
BEAUTIFY_QUERY.CONTRACT/Services/Services/Response.cs
BEAUTIFY_QUERY.CONTRACT/Services/ShiftConfigs/Query.cs
BEAUTIFY_QUERY.CONTRACT/Services/ShiftConfigs/Response.cs
BEAUTIFY_QUERY.CONTRACT/Services/Subscriptions/Query.cs
BEAUTIFY_QUERY.CONTRACT/Services/Subscriptions/Response.cs
BEAUTIFY_QUERY.CONTRACT/Services/SurveyQuestions/Query.cs
BEAUTIFY_QUERY.CONTRACT/Services/SurveyQuestions/Response.cs
BEAUTIFY_QUERY.CONTRACT/Services/Surveys/Query.cs
BEAUTIFY_QUERY.CONTRACT/Services/Surveys/Response.cs
BEAUTIFY_QUERY.CONTRACT/Services/Users/Query.cs
BEAUTIFY_QUERY.CONTRACT/Services/Users/Response.cs
BEAUTIFY_QUERY.CONTRACT/Services/WalletTransactions/Query.cs
BEAUTIFY_QUERY.CONTRACT/Services/WalletTransactions/Response.cs
BEAUTIFY_QUERY.CONTRACT/Services/WorkingSchedules/Query.cs
BEAUTIFY_QUERY.CONTRACT/Services/WorkingSchedules/Response.cs
BEAUTIFY_QUERY.DOMAIN/BEAUTIFY_QUERY.DOMAIN.csproj
BEAUTIFY_QUERY.DOMAIN/Constanst.cs
BEAUTIFY_QUERY.DOMAIN/Constrants/TableNames.cs
BEAUTIFY_QUERY.DOMAIN/Documents/ClinicServiceProjection.cs
BEAUTIFY_QUERY.DOMAIN/Documents/CustomerScheduleProjection.cs
BEAUTIFY_QUERY.DOMAIN/Documents/SubscriptionProjection.cs
BEAUTIFY_QUERY.DOMAIN/Documents/WorkingScheduleProjection.cs
BEAUTIFY_QUERY.DOMAIN/Entities/Category.cs
BEAUTIFY_QUERY.DOMAIN/Entities/Clinic.cs
BEAUTIFY_QUERY.DOMAIN/Entities/ClinicOnBoardingRequest.cs
BEAUTIFY_QUERY.DOMAIN/Entities/ClinicService.cs
BEAUTIFY_QUERY.DOMAIN/Entities/ClinicTransaction.cs
BEAUTIFY_QUERY.DOMAIN/Entities/ClinicVoucher.cs
BEAUTIFY_QUERY.DOMAIN/Entities/Config.cs
BEAUTIFY_QUERY.DOMAIN/Entities/Conversation.cs
BEAUTIFY_QUERY.DOMAIN/Entities/CustomerSchedule.cs
BEAUTIFY_QUERY.DOMAIN/Entities/DoctorCertificate.cs
BEAUTIFY_QUERY.DOMAIN/Entities/DoctorService.cs
BEAUTIFY_QUERY.DOMAIN/Entities/Feedback.cs
BEAUTIFY_QUERY.DOMAIN/Entities/LiveStreamDetail.cs
BEAUTIFY_QUERY.DOMAIN/Entities/LivestreamRoom.cs
BEAUTIFY_QUERY.DOMAIN/Entities/Message.cs
BEAUTIFY_QUERY.DOMAIN/Entities/Order.cs
BEAUTIFY_QUERY.DOMAIN/Entities/OrderDetail.cs
BEAUTIFY_QUERY.DOMAIN/Entities/OrderFeedback.cs
BEAUTIFY_QUERY.DOMAIN/Entities/OrderFeedbackMedia.cs
BEAUTIFY_QUERY.DOMAIN/Entities/Procedure.cs
BEAUTIFY_QUERY.DOMAIN/Entities/ProcedureMedia.cs
BEAUTIFY_QUERY.DOMAIN/Entities/ProcedurePriceTypes.cs
BEAUTIFY_QUERY.DOMAIN/Entities/Promotion.cs
BEAUTIFY_QUERY.DOMAIN/Entities/Role.cs
BEAUTIFY_QUERY.DOMAIN/Entities/Service.cs
BEAUTIFY_QUERY.DOMAIN/Entities/ServiceMedia.cs
BEAUTIFY_QUERY.DOMAIN/Entities/ShiftConfig.cs
BEAUTIFY_QUERY.DOMAIN/Entities/Staff.cs
BEAUTIFY_QUERY.DOMAIN/Entities/SubscriptionPackage.cs
BEAUTIFY_QUERY.DOMAIN/Entities/Survey.cs
BEAUTIFY_QUERY.DOMAIN/Entities/SurveyAnswer.cs
BEAUTIFY_QUERY.DOMAIN/Entities/SurveyQuestion.cs
BEAUTIFY_QUERY.DOMAIN/Entities/SurveyQuestionOption.cs
BEAUTIFY_QUERY.DOMAIN/Entities/SurveyResponse.cs
BEAUTIFY_QUERY.DOMAIN/Entities/SystemTransaction.cs
BEAUTIFY_QUERY.DOMAIN/Entities/User.cs
BEAUTIFY_QUERY.DOMAIN/Entities/UserClinic.cs
BEAUTIFY_QUERY.DOMAIN/Entities/UserConversation.cs
BEAUTIFY_QUERY.DOMAIN/Entities/Voucher.cs
BEAUTIFY_QUERY.DOMAIN/Entities/WalletTransaction.cs
BEAUTIFY_QUERY.DOMAIN/Entities/WorkingSchedule.cs
BEAUTIFY_QUERY.DOMAIN/Exceptions/BadRequestException.cs
BEAUTIFY_QUERY.DOMAIN/Exceptions/DoctorCertificateException.cs
BEAUTIFY_QUERY.DOMAIN/Exceptions/DomainException.cs
BEAUTIFY_QUERY.DOMAIN/Exceptions/IdentityException.cs
BEAUTIFY_QUERY.DOMAIN/Exceptions/NotFoundException.cs
BEAUTIFY_QUERY.DOMAIN/Exceptions/ProductException.cs
BEAUTIFY_QUERY.DOMAIN/GlobalUsings.cs
BEAUTIFY_QUERY.INFRASTRUCTURE/AssemblyReference.cs
BEAUTIFY_QUERY.INFRASTRUCTURE/BEAUTIFY_QUERY.INFRASTRUCTURE.csproj
BEAUTIFY_QUERY.INFRASTRUCTURE/Consumer/MessageBus/Consumers/Events/ClinicConsumer.cs
BEAUTIFY_QUERY.INFRASTRUCTURE/Consumer/MessageBus/Consumers/Events/ClinicServiceConsumer.cs
BEAUTIFY_QUERY.INFRASTRUCTURE/Consumer/MessageBus/Consumers/Events/CustomerScheduleConsumer.cs
BEAUTIFY_QUERY.INFRASTRUCTURE/Consumer/MessageBus/Consumers/Events/DoctorServicesConsumer.cs
BEAUTIFY_QUERY.INFRASTRUCTURE/Consumer/MessageBus/Consumers/Events/FeedbackConsumer.cs
BEAUTIFY_QUERY.INFRASTRUCTURE/Consumer/MessageBus/Consumers/Events/ServiceProcedureConsumer.cs
BEAUTIFY_QUERY.INFRASTRUCTURE/Consumer/MessageBus/Consumers/Events/ServicePromotionConsumer.cs
BEAUTIFY_QUERY.INFRASTRUCTURE/Consumer/MessageBus/Consumers/Events/UserClinicConsumer.cs
BEAUTIFY_QUERY.INFRASTRUCTURE/Consumer/MessageBus/Consumers/Events/WorkingScheduleConsumer.cs
BEAUTIFY_QUERY.INFRASTRUCTURE/Consumer/MessageBus/Consumers/PostgreConsumer/PostgreMigrateConsumer.cs
BEAUTIFY_QUERY.INFRASTRUCTURE/DependencyInjection/Extensions/ServiceCollectionExtensions.cs
BEAUTIFY_QUERY.PERSISTENCE/ApplicationDbContext.cs
BEAUTIFY_QUERY.PERSISTENCE/AssemblyReference.cs
BEAUTIFY_QUERY.PERSISTENCE/BEAUTIFY_QUERY.PERSISTENCE.csproj
BEAUTIFY_QUERY.PERSISTENCE/DependencyInjection/Extensions/ServiceCollectionExtensions.cs
BEAUTIFY_QUERY.PERSISTENCE/Repositories/MongoRepository.cs
BEAUTIFY_QUERY.PERSISTENCE/Repositories/RepositoryBase.cs
BEAUTIFY_QUERY.PRESENTATION/APIs/Bookings/Apis.cs
BEAUTIFY_QUERY.PRESENTATION/APIs/Categories/CategoryApi.cs
BEAUTIFY_QUERY.PRESENTATION/APIs/Clinics/ClinicApi.cs
BEAUTIFY_QUERY.PRESENTATION/APIs/CustomerSchedules/Apis.cs
BEAUTIFY_QUERY.PRESENTATION/APIs/Dashboard/DashboardApi.cs
BEAUTIFY_QUERY.PRESENTATION/APIs/DoctorCertificates/DoctorCertificateApi.cs
BEAUTIFY_QUERY.PRESENTATION/APIs/OrderDetails/Apis.cs
BEAUTIFY_QUERY.PRESENTATION/APIs/Orders/Apis.cs
BEAUTIFY_QUERY.PRESENTATION/APIs/Services/ServiceApi.cs
BEAUTIFY_QUERY.PRESENTATION/APIs/ShiftConfigs/ShiftConfigApi.cs
BEAUTIFY_QUERY.PRESENTATION/APIs/Subscriptions/SubscriptionApi.cs
BEAUTIFY_QUERY.PRESENTATION/APIs/SurveyQuestions/Apis.cs
BEAUTIFY_QUERY.PRESENTATION/APIs/Surveys/Apis.cs
BEAUTIFY_QUERY.PRESENTATION/APIs/Users/Apis.cs
BEAUTIFY_QUERY.PRESENTATION/APIs/WalletTransactions/Apis.cs
BEAUTIFY_QUERY.PRESENTATION/APIs/WorkingSchedules/WorkingScheduleApi.cs
BEAUTIFY_QUERY.PRESENTATION/BEAUTIFY_QUERY.PRESENTATION.csproj
BEAUTIFY_QUERY.PRESENTATION/Constrants/RoleNames.cs
BEAUTIFY_QUERY.PRESENTATION/GlobalUsings.cs
BEAUTIFY_QUERY.sln
BEAUTIFY_QUERY.sln.DotSettings
README.md

================================================================
Repository Files
================================================================

================
File: BEAUTIFY_QUERY.API/BEAUTIFY_QUERY.API.csproj
================
<Project Sdk="Microsoft.NET.Sdk.Web">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
        <DockerDefaultTargetOS>Linux</DockerDefaultTargetOS>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="BEAUTIFY_PACKAGES.SHARE" Version="1.12.6" />
        <PackageReference Include="Carter" Version="7.2.0" />
        <PackageReference Include="MicroElements.Swashbuckle.FluentValidation" Version="6.1.0" />
        <PackageReference Include="Serilog" Version="4.2.0" />
        <PackageReference Include="Swashbuckle.AspNetCore" Version="6.6.2" />
    </ItemGroup>

    <ItemGroup>
        <Folder Include="Controllers\" />
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\BEAUTIFY_QUERY.INFRASTRUCTURE\BEAUTIFY_QUERY.INFRASTRUCTURE.csproj" />
    </ItemGroup>

    <ItemGroup>
        <Content Include="..\.dockerignore">
            <Link>.dockerignore</Link>
        </Content>
    </ItemGroup>

    <ItemGroup>
        <PackageVersion Update="BEAUTIFY_PACKAGES.SHARE" Version="1.6.0" />
    </ItemGroup>

</Project>

================
File: BEAUTIFY_QUERY.API/DependencyInjection/Extensions/JwtExtensions.cs
================
using System.Text;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Constrants;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.INFRASTRUCTURE.DependencyInjection.Options;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;

namespace BEAUTIFY_QUERY.API.DependencyInjection.Extensions;
public static class JwtExtensions
{
    public static void AddJwtAuthenticationAPI1(this IServiceCollection services, IConfiguration configuration)
    {
        services.AddAuthentication(options =>
        {
            options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
            options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
            options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;
        }).AddJwtBearer(o =>
        {
            var jwtOption = new JwtOption();
            configuration.GetSection(nameof(JwtOption)).Bind(jwtOption);

            /**
             * Storing the JWT in the AuthenticationProperties allows you to retrieve it from elsewhere within your application.
             * public async Task<IActionResult> SomeAction()
                {
                    // using Microsoft.AspNetCore.Authentication;
                    var accessToken = await HttpContext.GetTokenAsync("access_token");
                    // ...
                }
             */
            o.SaveToken = true; // Save token into AuthenticationProperties

            var Key = Encoding.UTF8.GetBytes(jwtOption.SecretKey);
            o.TokenValidationParameters = new TokenValidationParameters
            {
                ValidateIssuer = true, // on production make it true
                ValidateAudience = true, // on production make it true
                ValidateLifetime = true,
                ValidateIssuerSigningKey = true,
                ValidIssuer = jwtOption.Issuer,
                ValidAudience = jwtOption.Audience,
                IssuerSigningKey = new SymmetricSecurityKey(Key),
                ClockSkew = TimeSpan.Zero
            };

            o.Events = new JwtBearerEvents
            {
                OnAuthenticationFailed = context =>
                {
                    if (context.Exception.GetType() == typeof(SecurityTokenExpiredException))
                        context.Response.Headers.Add("IS-TOKEN-EXPIRED", "true");
                    return Task.CompletedTask;
                }
            };

            //o.EventsType = typeof(CustomJwtBearerEvents);
        });

        services.AddAuthorizationBuilder()
            .AddPolicy(Constant.Role.CLINIC_STAFF, policy => policy.RequireRole(Constant.Role.CLINIC_STAFF))
            .AddPolicy(Constant.Role.CLINIC_ADMIN, policy => policy.RequireRole(Constant.Role.CLINIC_ADMIN))
            .AddPolicy(Constant.Role.DOCTOR, policy => policy.RequireRole(Constant.Role.DOCTOR))
            .AddPolicy(Constant.Role.CUSTOMER, policy => policy.RequireRole(Constant.Role.CUSTOMER))
            .AddPolicy(Constant.Role.SYSTEM_ADMIN, policy => policy.RequireRole(Constant.Role.SYSTEM_ADMIN))
            .AddPolicy(Constant.Role.SYSTEM_STAFF, policy => policy.RequireRole(Constant.Role.SYSTEM_STAFF))
            .AddPolicy(Constant.Policy.POLICY_DOCTOR_AND_CUSTOMER,
                policy => policy.RequireRole(Constant.Role.DOCTOR, Constant.Role.CUSTOMER))
            .AddPolicy(Constant.Policy.POLICY_CLINIC_ADMIN_AND_SYSTEM_STAFF,
                policy => policy.RequireRole(Constant.Role.CLINIC_ADMIN, Constant.Role.SYSTEM_STAFF))
            .AddPolicy(Constant.Policy.POLICY_CLINIC_ADMIN_AND_CLINIC_STAFF,
                policy => policy.RequireRole(Constant.Role.CLINIC_ADMIN, Constant.Role.CLINIC_STAFF));


        // services.AddScoped<CustomJwtBearerEvents>();
    }
}

================
File: BEAUTIFY_QUERY.API/Dockerfile
================
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
USER $APP_UID
WORKDIR /app
EXPOSE 8080
EXPOSE 8081

FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
ARG BUILD_CONFIGURATION=Release
WORKDIR /src
COPY ["BEAUTIFY_QUERY.API/BEAUTIFY_QUERY.API.csproj", "BEAUTIFY_QUERY.API/"]
COPY ["BEAUTIFY_QUERY.DOMAIN/BEAUTIFY_QUERY.DOMAIN.csproj", "BEAUTIFY_QUERY.DOMAIN/"]
COPY ["BEAUTIFY_QUERY.APPLICATION/BEAUTIFY_QUERY.APPLICATION.csproj", "BEAUTIFY_QUERY.APPLICATION/"]
COPY ["BEAUTIFY_QUERY.CONTRACT/BEAUTIFY_QUERY.CONTRACT.csproj", "BEAUTIFY_QUERY.CONTRACT/"]
COPY ["BEAUTIFY_QUERY.INFRASTRUCTURE/BEAUTIFY_QUERY.INFRASTRUCTURE.csproj", "BEAUTIFY_QUERY.INFRASTRUCTURE/"]
COPY ["BEAUTIFY_QUERY.PERSISTENCE/BEAUTIFY_QUERY.PERSISTENCE.csproj", "BEAUTIFY_QUERY.PERSISTENCE/"]
COPY ["BEAUTIFY_QUERY.PRESENTATION/BEAUTIFY_QUERY.PRESENTATION.csproj", "BEAUTIFY_QUERY.PRESENTATION/"]
RUN dotnet restore "BEAUTIFY_QUERY.API/BEAUTIFY_QUERY.API.csproj"
COPY . .
WORKDIR "/src/BEAUTIFY_QUERY.API"
RUN dotnet build "BEAUTIFY_QUERY.API.csproj" -c $BUILD_CONFIGURATION -o /app/build --no-restore -p:TreatWarningsAsErrors=false -p:NoWarn=all

FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "BEAUTIFY_QUERY.API.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=false

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "BEAUTIFY_QUERY.API.dll"]

================
File: BEAUTIFY_QUERY.API/Middlewares/ExceptionHandlingMiddleware.cs
================
using System.Text.Json;
using BEAUTIFY_QUERY.APPLICATION.Exceptions;
using BEAUTIFY_QUERY.DOMAIN.Exceptions;

namespace BEAUTIFY_QUERY.API.Middlewares;
internal sealed class ExceptionHandlingMiddleware : IMiddleware
{
    private readonly ILogger<ExceptionHandlingMiddleware> _logger;

    public ExceptionHandlingMiddleware(ILogger<ExceptionHandlingMiddleware> logger)
    {
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        try
        {
            await next(context);
        }
        catch (Exception e)
        {
            _logger.LogError(e, e.Message);

            await HandleExceptionAsync(context, e);
        }
    }

    private static async Task HandleExceptionAsync(HttpContext httpContext, Exception exception)
    {
        var statusCode = GetStatusCode(exception);

        var response = new
        {
            title = GetTitle(exception),
            status = statusCode,
            detail = exception.Message,
            errors = GetErrors(exception)
        };

        httpContext.Response.ContentType = "application/json";

        httpContext.Response.StatusCode = statusCode;

        await httpContext.Response.WriteAsync(JsonSerializer.Serialize(response));
    }

    private static int GetStatusCode(Exception exception)
    {
        return exception switch
        {
            // IdentityException.TokenException => StatusCodes.Status401Unauthorized,
            // ProductException.ProductFieldException => StatusCodes.Status406NotAcceptable, // Should be remove later
            // BadRequestException => StatusCodes.Status400BadRequest,
            // NotFoundException => StatusCodes.Status404NotFound,
            // ValidationException => StatusCodes.Status422UnprocessableEntity,
            // FluentValidation.ValidationException => StatusCodes.Status400BadRequest,
            // FormatException => StatusCodes.Status422UnprocessableEntity,
            _ => StatusCodes.Status500InternalServerError
        };
    }

    private static string GetTitle(Exception exception)
    {
        return exception switch
        {
            DomainException applicationException => applicationException.Title,
            _ => "Server Error"
        };
    }

    private static IReadOnlyCollection<ValidationError>? GetErrors(Exception exception)
    {
        IReadOnlyCollection<ValidationError> errors = null;

        if (exception is ValidationException validationException) errors = validationException.Errors;

        return errors;
    }
}

================
File: BEAUTIFY_QUERY.API/Program.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.API.DependencyInjection.Extensions;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Repositories;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.PERSISTENCE.DependencyInjection.Options;
using BEAUTIFY_QUERY.API.DependencyInjection.Extensions;
using BEAUTIFY_QUERY.API.Middlewares;
using BEAUTIFY_QUERY.APPLICATION.DependencyInjection.Extensions;
using BEAUTIFY_QUERY.INFRASTRUCTURE.DependencyInjection.Extensions;
using BEAUTIFY_QUERY.PERSISTENCE.DependencyInjection.Extensions;
using Carter;
using MicroElements.Swashbuckle.FluentValidation.AspNetCore;
using Serilog;

var builder = WebApplication.CreateBuilder(args);

Log.Logger = new LoggerConfiguration().ReadFrom
    .Configuration(builder.Configuration)
    .CreateLogger();

builder.Logging
    .ClearProviders()
    .AddSerilog();

builder.Host.UseSerilog((context, services, configuration) => configuration
    .ReadFrom.Configuration(context.Configuration)
    .ReadFrom.Services(services)
    .Enrich.FromLogContext()
    .WriteTo.File("Logs/logs.txt", rollingInterval: RollingInterval.Day)
    .WriteTo.Console());
// Add Carter module
builder.Services.AddCarter();

builder.Services
    .AddSwaggerGenNewtonsoftSupport()
    .AddFluentValidationRulesToSwagger()
    .AddEndpointsApiExplorer()
    .AddSwaggerAPI();

builder.Services
    .AddApiVersioning(options => options.ReportApiVersions = true)
    .AddApiExplorer(options =>
    {
        options.GroupNameFormat = "'v'VVV";
        options.SubstituteApiVersionInUrl = true;
    });

builder.Services.ConfigureCors();

// Application Layer
builder.Services.AddMediatRApplication();
builder.Services.AddAutoMapperApplication();

// Persistence Layer

// =====================>
builder.Services.ConfigureSqlServerRetryOptionsPersistence(
    builder.Configuration.GetSection(nameof(SqlServerRetryOptions))
);

// builder.Services.ConfigurePostgreSqlRetryOptionsPersistence(
//     builder.Configuration.GetSection(nameof(PostgreSqlRetryOptions))
// );

// =====================>
builder.Services.AddSqlServerPersistence();
// builder.Services.AddPostgreSqlPersistence();

builder.Services.AddRepositoryPersistence();
builder.Services.ConfigureServicesInfrastructure(builder.Configuration);

// Infrastructure Layer
builder.Services.AddServicesInfrastructure();
builder.Services.AddRedisInfrastructure(builder.Configuration);
builder.Services.AddMediatRInfrastructure();
builder.Services.AddMasstransitRabbitMqInfrastructure(builder.Configuration);
// builder.Services.ConfigureHealthChecks(builder.Configuration);
builder.Services.AddJwtAuthenticationAPI1(builder.Configuration);

builder.Services.AddTransient<ExceptionHandlingMiddleware>();
builder.Services.AddTransient<ICurrentUserService, CurrentUserService>();
builder.Services.AddHttpContextAccessor();

var app = builder.Build();

// Using middleware
app.UseMiddleware<ExceptionHandlingMiddleware>();

// Configure the HTTP request pipeline. 
// if (builder.Environment.IsDevelopment() || builder.Environment.IsStaging())
app.UseSwaggerAPI(); // => After MapCarter => Show Version

app.UseCors("CorsPolicy");

// app.UseHttpsRedirection();
// app.UseRouting();

app.UseAuthentication(); // Need to be before app.UseAuthorization();
app.UseAuthorization();

// app.MapDefaultHealthChecks();
// app.MapDefaultHealthChecksUI();

// 7. Map Carter endpoints
app.MapCarter();

try
{
    await app.RunAsync();
    Log.Information("Stopped cleanly");
}
catch (Exception ex)
{
    Log.Fatal(ex, "An unhandled exception occured during bootstrapping");
    await app.StopAsync();
}
finally
{
    Log.CloseAndFlush();
    await app.DisposeAsync();
}

================
File: BEAUTIFY_QUERY.API/Properties/launchSettings.json
================
{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:41522",
      "sslPort": 0
    }
  },
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "http://localhost:5229",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "launchUrl": "swagger",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}

================
File: BEAUTIFY_QUERY.APPLICATION.Tests/BEAUTIFY_QUERY.APPLICATION.Tests.csproj
================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
        <IsPackable>false</IsPackable>
        <RootNamespace>BEAUTIFY_QUERY.APPLICATION.Tests</RootNamespace>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.8.0" />
        <PackageReference Include="xunit" Version="2.6.2" />
        <PackageReference Include="xunit.runner.visualstudio" Version="2.5.4">
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
            <PrivateAssets>all</PrivateAssets>
        </PackageReference>
        <PackageReference Include="coverlet.collector" Version="6.0.0">
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
            <PrivateAssets>all</PrivateAssets>
        </PackageReference>
        <PackageReference Include="BEAUTIFY_PACKAGES.SHARE" Version="1.12.6" />
        <PackageReference Include="Moq" Version="4.20.69" />
        <PackageReference Include="Microsoft.EntityFrameworkCore" Version="8.0.7" />
    </ItemGroup>

    <ItemGroup>
        <Folder Include="UseCases\Queries\WorkingSchedules\" />
    </ItemGroup>

    <ItemGroup>
      <ProjectReference Include="..\BEAUTIFY_QUERY.APPLICATION\BEAUTIFY_QUERY.APPLICATION.csproj" />
    </ItemGroup>

</Project>

================
File: BEAUTIFY_QUERY.APPLICATION.Tests/UseCases/Queries/Orders/GetClinicOrderBranchesQueryHandlerTests.cs
================
using System.Collections;
using System.Linq.Expressions;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Enumerations;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Repositories;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Constrants;
using BEAUTIFY_QUERY.APPLICATION.UseCases.Queries.Orders;
using BEAUTIFY_QUERY.CONTRACT.Services.Orders;
using BEAUTIFY_QUERY.DOMAIN.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Query;
using Moq;
using Xunit;

namespace BEAUTIFY_QUERY.APPLICATION.Tests.UseCases.Queries.Orders;
public class GetClinicOrderBranchesQueryHandlerTests
{
    private readonly GetClinicOrderBranchesQueryHandler _handler;
    private readonly Mock<IRepositoryBase<Clinic, Guid>> _mockClinicRepository;
    private readonly Mock<ICurrentUserService> _mockCurrentUserService;
    private readonly Mock<IRepositoryBase<Order, Guid>> _mockOrderRepository;

    public GetClinicOrderBranchesQueryHandlerTests()
    {
        _mockCurrentUserService = new Mock<ICurrentUserService>();
        _mockOrderRepository = new Mock<IRepositoryBase<Order, Guid>>();
        _mockClinicRepository = new Mock<IRepositoryBase<Clinic, Guid>>();
        _handler = new GetClinicOrderBranchesQueryHandler(
            _mockCurrentUserService.Object,
            _mockOrderRepository.Object,
            _mockClinicRepository.Object);
    }

    [Fact]
    public async Task Handle_WithServiceNameSearch_FiltersCorrectly()
    {
        // Arrange
        var parentClinicId = Guid.NewGuid();
        var childClinicId = Guid.NewGuid();
        var customer1Id = Guid.NewGuid();
        var customer2Id = Guid.NewGuid();

        _mockCurrentUserService.Setup(x => x.ClinicId).Returns(parentClinicId);

        var parentClinic = new Clinic
        {
            Id = parentClinicId,
            IsParent = true,
            Name = "Parent Clinic",
            Email = "parent@example.com",
            PhoneNumber = "1234567890",
            TaxCode = "TAX123",
            BusinessLicenseUrl = "https://example.com/business-license",
            OperatingLicenseUrl = "https://example.com/operating-license"
        };
        var childClinics = new List<Clinic>
        {
            new()
            {
                Id = childClinicId,
                ParentId = parentClinicId,
                Name = "Child Clinic",
                Email = "child@example.com",
                PhoneNumber = "1234567891",
                TaxCode = "TAX124",
                BusinessLicenseUrl = "https://example.com/business-license-child",
                OperatingLicenseUrl = "https://example.com/operating-license-child"
            }
        };

        _mockClinicRepository.Setup(x => x.FindByIdAsync(parentClinicId, It.IsAny<CancellationToken>()))
            .ReturnsAsync(parentClinic);

        // Mock DbSet for child clinics
        var mockChildClinicDbSet = CreateMockDbSet(childClinics);
        _mockClinicRepository.Setup(x => x.FindAll(It.IsAny<Expression<Func<Clinic, bool>>>()))
            .Returns(mockChildClinicDbSet.Object);

        // Create orders with different service names
        var orders = new List<Order>
        {
            new()
            {
                Id = Guid.NewGuid(),
                CustomerId = customer1Id,
                Customer = new User
                {
                    FirstName = "John",
                    LastName = "Doe",
                    Password = "123",
                    PhoneNumber = "1234567890",
                    Email = "john@example.com",
                    Status = 1
                },
                Service = new Service
                {
                    Name = "Haircut", // This should match
                    Description = "Standard haircut service",
                    ClinicServices = new List<ClinicService>
                    {
                        new() { ClinicId = childClinicId }
                    }
                },
                DepositAmount = 25,
                FinalAmount = 100
            },
            new()
            {
                Id = Guid.NewGuid(),
                CustomerId = customer2Id,
                Customer = new User
                {
                    FirstName = "Jane",
                    LastName = "Smith",
                    Password = "123",
                    PhoneNumber = "9876543210",
                    Email = "jane@example.com",
                    Status = 1
                },
                Service = new Service
                {
                    Name = "Manicure", // This shouldn't match
                    Description = "Standard manicure service",
                    ClinicServices = new List<ClinicService>
                    {
                        new() { ClinicId = childClinicId }
                    }
                },
                DepositAmount = 10,
                FinalAmount = 50
            }
        };

        // Return ALL orders via the repository
        // Let the handler filter them instead
        var mockOrderDbSet = CreateMockDbSet(orders);
        _mockOrderRepository.Setup(x => x.FindAll(It.IsAny<Expression<Func<Order, bool>>>()))
            .Returns(mockOrderDbSet.Object);

        var query = new Query.GetClinicOrderBranchesQuery(
            "Hair",
            "serviceName", // This should be correct now
            SortOrder.Ascending,
            0,
            10);

        // Act
        var result = await _handler.Handle(query, CancellationToken.None);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.NotNull(result.Value);
        Assert.Single(result.Value.Items);
        Assert.Equal("Haircut", result.Value.Items.First().ServiceName);
    }

    [Fact]
    public async Task Handle_WithValidParentClinic_ReturnsOrdersFromChildClinics()
    {
        // Arrange
        var parentClinicId = Guid.NewGuid();
        var childClinic1Id = Guid.NewGuid();
        var childClinic2Id = Guid.NewGuid();
        var orderId = Guid.NewGuid();
        var customerId = Guid.NewGuid();

        _mockCurrentUserService.Setup(x => x.ClinicId).Returns(parentClinicId);

        var parentClinic = new Clinic
        {
            Id = parentClinicId,
            IsParent = true,
            Name = "Parent Clinic",
            Email = "parent@example.com",
            PhoneNumber = "1234567890",
            TaxCode = "TAX123",
            BusinessLicenseUrl = "https://example.com/business-license",
            OperatingLicenseUrl = "https://example.com/operating-license"
        };
        var childClinics = new List<Clinic>
        {
            new()
            {
                Id = childClinic1Id,
                ParentId = parentClinicId,
                Name = "Child Clinic 1",
                Email = "child1@example.com",
                PhoneNumber = "1234567891",
                TaxCode = "TAX124",
                BusinessLicenseUrl = "https://example.com/business-license1",
                OperatingLicenseUrl = "https://example.com/operating-license1"
            },
            new()
            {
                Id = childClinic2Id,
                ParentId = parentClinicId,
                Name = "Child Clinic 2",
                Email = "child2@example.com",
                PhoneNumber = "1234567892",
                TaxCode = "TAX125",
                BusinessLicenseUrl = "https://example.com/business-license2",
                OperatingLicenseUrl = "https://example.com/operating-license2"
            }
        };

        _mockClinicRepository.Setup(x => x.FindByIdAsync(parentClinicId, It.IsAny<CancellationToken>()))
            .ReturnsAsync(parentClinic);

        // Create a mock DbSet for child clinics
        var mockChildDbSet = CreateMockDbSet(childClinics);

        // Set up the FindAll method to return our mock DbSet
        _mockClinicRepository.Setup(x => x.FindAll(It.IsAny<Expression<Func<Clinic, bool>>>()))
            .Returns(mockChildDbSet.Object);

        var orders = new List<Order>
        {
            new()
            {
                Id = orderId,
                CustomerId = customerId,
                Customer = new User
                {
                    FirstName = "John",
                    LastName = "Doe",
                    Password = "1",
                    PhoneNumber = "1234567890",
                    Email = "john@example.com",
                    Status = 1
                },
                Service = new Service
                {
                    Name = "Haircut",
                    Description = "Standard haircut service",
                    ClinicServices = new List<ClinicService>
                    {
                        new() { ClinicId = childClinic1Id }
                    }
                },
                TotalAmount = 100,
                Discount = 10,
                DepositAmount = 20,
                FinalAmount = 90,
                OrderDate = DateOnly.FromDateTime(DateTime.Now),
                Status = Constant.OrderStatus.ORDER_COMPLETED
            }
        };

        // Create a mock DbSet for orders that supports async operations
        var mockOrderDbSet = CreateMockDbSet(orders);

        // Set up the FindAll method to return our mock DbSet
        _mockOrderRepository.Setup(x => x.FindAll(It.IsAny<Expression<Func<Order, bool>>>()))
            .Returns(mockOrderDbSet.Object);

        var query = new Query.GetClinicOrderBranchesQuery(
            "John",
            "customerName",
            SortOrder.Ascending,
            0,
            10);

        // Act
        var result = await _handler.Handle(query, CancellationToken.None);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.NotNull(result.Value);
        Assert.Single(result.Value.Items);
        Assert.Equal(orderId, result.Value.Items.First().Id);
        Assert.Equal("John Doe", result.Value.Items.First().CustomerName);
    }

    [Fact]
    public async Task Handle_WithNonParentClinic_ReturnsFailure()
    {
        // Arrange
        var clinicId = Guid.NewGuid();
        _mockCurrentUserService.Setup(x => x.ClinicId).Returns(clinicId);

        var clinic = new Clinic
        {
            Id = clinicId,
            IsParent = false,
            Name = "Non-Parent Clinic",
            Email = "non-parent@example.com",
            PhoneNumber = "1234567890",
            TaxCode = "TAX126",
            BusinessLicenseUrl = "https://example.com/business-license-np",
            OperatingLicenseUrl = "https://example.com/operating-license-np"
        };
        _mockClinicRepository.Setup(x => x.FindByIdAsync(clinicId, It.IsAny<CancellationToken>()))
            .ReturnsAsync(clinic);

        var query = new Query.GetClinicOrderBranchesQuery(
            null,
            null,
            SortOrder.Ascending,
            0,
            10);

        // Act
        var result = await _handler.Handle(query, CancellationToken.None);

        // Assert
        Assert.True(result.IsFailure);
        Assert.Equal("403", result.Error.Code);
        Assert.Equal("Only parent clinics can access this endpoint", result.Error.Message);
    }

    [Fact]
    public async Task Handle_WithSearchTerm_FiltersCorrectly()
    {
        // Arrange
        var parentClinicId = Guid.NewGuid();
        var childClinicId = Guid.NewGuid();
        var customer1Id = Guid.NewGuid();
        var customer2Id = Guid.NewGuid();

        _mockCurrentUserService.Setup(x => x.ClinicId).Returns(parentClinicId);

        var parentClinic = new Clinic
        {
            Id = parentClinicId,
            IsParent = true,
            Name = "Parent Clinic",
            Email = "parent@example.com",
            PhoneNumber = "1234567890",
            TaxCode = "TAX123",
            BusinessLicenseUrl = "https://example.com/business-license",
            OperatingLicenseUrl = "https://example.com/operating-license"
        };
        var childClinics = new List<Clinic>
        {
            new()
            {
                Id = childClinicId,
                ParentId = parentClinicId,
                Name = "Child Clinic",
                Email = "child@example.com",
                PhoneNumber = "1234567891",
                TaxCode = "TAX124",
                BusinessLicenseUrl = "https://example.com/business-license-child",
                OperatingLicenseUrl = "https://example.com/operating-license-child"
            }
        };

        _mockClinicRepository.Setup(x => x.FindByIdAsync(parentClinicId, It.IsAny<CancellationToken>()))
            .ReturnsAsync(parentClinic);

        // Mock DbSet for child clinics
        var mockChildClinicDbSet = CreateMockDbSet(childClinics);
        _mockClinicRepository.Setup(x => x.FindAll(It.IsAny<Expression<Func<Clinic, bool>>>()))
            .Returns(mockChildClinicDbSet.Object);

        // Create orders with "John" in the name for testing search functionality
        var orders = new List<Order>
        {
            new()
            {
                Id = Guid.NewGuid(),
                CustomerId = customer1Id,
                Customer = new User
                {
                    FirstName = "John",
                    Password = "123",
                    LastName = "Doe",
                    PhoneNumber = "1234567890",
                    Email = "john@example.com",
                    Status = 1
                },
                Service = new Service
                {
                    Name = "Haircut",
                    Description = "Standard haircut service",
                    ClinicServices = new List<ClinicService>
                    {
                        new() { ClinicId = childClinicId }
                    }
                },
                DepositAmount = 25,
                FinalAmount = 100
            },
            new()
            {
                Id = Guid.NewGuid(),
                CustomerId = customer2Id,
                Customer = new User
                {
                    FirstName = "Jane",
                    LastName = "Smith",
                    Password = "123",
                    PhoneNumber = "9876543210",
                    Email = "jane@example.com",
                    Status = 1
                },
                Service = new Service
                {
                    Name = "Manicure",
                    Description = "Standard manicure service",
                    ClinicServices = new List<ClinicService>
                    {
                        new() { ClinicId = childClinicId }
                    }
                },
                DepositAmount = 10,
                FinalAmount = 50
            }
        };

        // Only return John's order when searching for "john" 
        var filteredOrders = orders.Where(o =>
            o.Customer != null &&
            (o.Customer.FirstName + " " + o.Customer.LastName).Contains("john", StringComparison.OrdinalIgnoreCase)
        ).ToList();

        // Create mock DbSet that returns filtered results
        var mockOrderDbSet = CreateMockDbSet(filteredOrders);
        _mockOrderRepository.Setup(x => x.FindAll(It.IsAny<Expression<Func<Order, bool>>>()))
            .Returns(mockOrderDbSet.Object);

        var query = new Query.GetClinicOrderBranchesQuery(
            "john",
            "customerName",
            SortOrder.Ascending,
            0,
            10);

        // Act
        var result = await _handler.Handle(query, CancellationToken.None);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.NotNull(result.Value);
        Assert.Single(result.Value.Items);
        Assert.Equal("John Doe", result.Value.Items.First().CustomerName);
    }

    // Helper method to create a mock DbSet that supports async operations
    private static Mock<DbSet<T>> CreateMockDbSet<T>(List<T> data) where T : class
    {
        var queryableData = data.AsQueryable();
        var mockDbSet = new Mock<DbSet<T>>();

        // Setup for synchronous operations
        mockDbSet.As<IQueryable<T>>().Setup(m => m.Provider)
            .Returns(new TestAsyncQueryProvider<T>(queryableData.Provider));
        mockDbSet.As<IQueryable<T>>().Setup(m => m.Expression).Returns(queryableData.Expression);
        mockDbSet.As<IQueryable<T>>().Setup(m => m.ElementType).Returns(queryableData.ElementType);
        mockDbSet.As<IQueryable<T>>().Setup(m => m.GetEnumerator()).Returns(() => queryableData.GetEnumerator());

        // Setup for asynchronous operations
        mockDbSet.As<IAsyncEnumerable<T>>()
            .Setup(m => m.GetAsyncEnumerator(It.IsAny<CancellationToken>()))
            .Returns(new TestAsyncEnumerator<T>(data.GetEnumerator()));

        return mockDbSet;
    }
}

// Required helper classes for async querying
// These classes help with the mocking of async EF Core operations
public class TestAsyncQueryProvider<TEntity> : IAsyncQueryProvider
{
    private readonly IQueryProvider _inner;

    public TestAsyncQueryProvider(IQueryProvider inner)
    {
        _inner = inner;
    }

    public IQueryable CreateQuery(Expression expression)
    {
        return new TestAsyncEnumerable<TEntity>(expression);
    }

    public IQueryable<TElement> CreateQuery<TElement>(Expression expression)
    {
        return new TestAsyncEnumerable<TElement>(expression);
    }

    public object Execute(Expression expression)
    {
        return _inner.Execute(expression);
    }

    public TResult Execute<TResult>(Expression expression)
    {
        return _inner.Execute<TResult>(expression);
    }

    // Fixed: Simplified ExecuteAsync method to avoid reflection errors
    public TResult ExecuteAsync<TResult>(Expression expression, CancellationToken cancellationToken = default)
    {
        // For common EF Core async operations (Count, First, etc.), we'll execute them synchronously
        // This works because we're dealing with in-memory collections
        var result = _inner.Execute<TResult>(expression);

        // For Task<T> or ValueTask<T> results, we need to wrap them
        if (!typeof(TResult).IsGenericType ||
            (typeof(TResult).GetGenericTypeDefinition() != typeof(Task<>) &&
             typeof(TResult).GetGenericTypeDefinition() != typeof(ValueTask<>))) return result;
        // Get the T from Task<T> or ValueTask<T>
        var resultType = typeof(TResult).GetGenericArguments()[0];

        // For Task<T>
        if (typeof(TResult).GetGenericTypeDefinition() == typeof(Task<>))
        {
            var methodInfo = typeof(Task).GetMethod(nameof(Task.FromResult));
            var genericMethod = methodInfo.MakeGenericMethod(resultType);

            // Get the underlying result
            var innerResult = _inner.Execute(expression);
            if (innerResult is not IEnumerable enumerable || resultType == typeof(IEnumerable))
                return (TResult)genericMethod.Invoke(null, new[] { innerResult });
            // If the result is IEnumerable but the expected return type is something like int, 
            // we need to handle specific operations like Count, Sum, etc.
            if (resultType == typeof(int))
            {
                // Most likely Count or Sum
                innerResult = enumerable.Cast<object>().Count();
            }

            return (TResult)genericMethod.Invoke(null, new[] { innerResult });
        }

        // For ValueTask<T>
        var valueTaskConstructor = typeof(ValueTask<>).MakeGenericType(resultType)
            .GetConstructor(new[] { resultType });
        if (valueTaskConstructor != null)
        {
            return (TResult)valueTaskConstructor.Invoke(new[] { _inner.Execute(expression) });
        }

        return result;
    }

    public IAsyncEnumerable<TResult> ExecuteAsync<TResult>(Expression expression)
    {
        return new TestAsyncEnumerable<TResult>(expression);
    }
}

// Fixed: Removed circular provider reference
public class TestAsyncEnumerable<T> : EnumerableQuery<T>, IAsyncEnumerable<T>, IQueryable<T>
{
    private readonly IQueryProvider _provider;

    public TestAsyncEnumerable(IEnumerable<T> enumerable)
        : base(enumerable)
    {
        _provider = new TestAsyncQueryProvider<T>(((IQueryable)this).Provider);
    }

    public TestAsyncEnumerable(Expression expression)
        : base(expression)
    {
        _provider = new TestAsyncQueryProvider<T>(((IQueryable)this).Provider);
    }

    public IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default)
    {
        return new TestAsyncEnumerator<T>(this.AsEnumerable().GetEnumerator());
    }

    // Fixed: Don't create a new provider each time, which creates a circular reference
    IQueryProvider IQueryable.Provider => _provider;
}

public class TestAsyncEnumerator<T>(IEnumerator<T> inner) : IAsyncEnumerator<T>
{
    public T Current => inner.Current;

    public ValueTask<bool> MoveNextAsync()
    {
        return new ValueTask<bool>(inner.MoveNext());
    }

    public ValueTask DisposeAsync()
    {
        inner.Dispose();
        return ValueTask.CompletedTask;
    }
}

================
File: BEAUTIFY_QUERY.APPLICATION.Tests/UseCases/Queries/Orders/GetOrdersByCustomerIdQueryHandlerTests.cs
================
using System.Linq.Expressions;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Enumerations;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Repositories;
using BEAUTIFY_QUERY.APPLICATION.UseCases.Queries.Orders;
using BEAUTIFY_QUERY.CONTRACT.Services.Orders;
using BEAUTIFY_QUERY.DOMAIN.Entities;
using Microsoft.EntityFrameworkCore;
using Moq;
using Xunit;

namespace BEAUTIFY_QUERY.APPLICATION.Tests.UseCases.Queries.Orders;
public class GetOrdersByCustomerIdQueryHandlerTests
{
    private readonly GetOrdersByCustomerIdQueryHandler _handler;
    private readonly Mock<ICurrentUserService> _mockCurrentUserService;
    private readonly Mock<IRepositoryBase<Order, Guid>> _mockOrderRepository;

    public GetOrdersByCustomerIdQueryHandlerTests()
    {
        _mockOrderRepository = new Mock<IRepositoryBase<Order, Guid>>();
        _mockCurrentUserService = new Mock<ICurrentUserService>();
        _handler = new GetOrdersByCustomerIdQueryHandler(
            _mockOrderRepository.Object,
            _mockCurrentUserService.Object);

        // Patch PagedResult.CreateAsync
        SetupMockPagedResult();
    }

    private void SetupMockPagedResult()
    {
        // Fix: Add the cancellationToken parameter to the callback
        _mockOrderRepository.Setup(r => r.FindAll(It.IsAny<Expression<Func<Order, bool>>>()))
            .Returns((Expression<Func<Order, bool>> predicate) =>
            {
                // Create a mock DbSet with our MockDbSet helper
                var allOrders = GetSampleOrders();
                // Filter the orders based on the predicate
                var filteredOrders = allOrders.AsQueryable().Where(predicate).ToList();
                return CreateMockDbSet(filteredOrders).Object;
            });
    }

    private List<Order> GetSampleOrders()
    {
        var userId = Guid.Parse("00000000-0000-0000-0000-000000000001");
        return new List<Order>
        {
            new Order
            {
                Id = Guid.Parse("10000000-0000-0000-0000-000000000001"),
                CustomerId = userId,
                Customer = new User
                {
                    Id = userId,
                    FirstName = "John",
                    LastName = "Doe",
                    Password = "123",
                    PhoneNumber = "1234567890",
                    Email = "john@example.com",
                    Status = 1
                },
                Service = new Service
                {
                    Name = "Haircut",
                    Description = "Standard haircut service"
                },
                TotalAmount = 100,
                Discount = 10,
                DepositAmount = 20,
                FinalAmount = 90,
                OrderDate = DateOnly.FromDateTime(DateTime.Now),
                CreatedOnUtc = DateTime.UtcNow
            },
            new Order
            {
                Id = Guid.Parse("20000000-0000-0000-0000-000000000001"),
                CustomerId = userId,
                Customer = new User
                {
                    Id = userId,
                    FirstName = "John",
                    LastName = "Doe",
                    Password = "123",
                    PhoneNumber = "1234567890",
                    Email = "john@example.com",
                    Status = 1
                },
                Service = new Service
                {
                    Name = "Manicure",
                    Description = "Standard manicure service"
                },
                TotalAmount = 50,
                Discount = 5,
                DepositAmount = 10,
                FinalAmount = 45,
                OrderDate = DateOnly.FromDateTime(DateTime.Now.AddDays(-1)),
                CreatedOnUtc = DateTime.UtcNow.AddDays(-1)
            }
        };
    }

    [Fact]
    public async Task Handle_ReturnsCustomerOrders_WhenCustomerHasOrders()
    {
        // Arrange
        var userId = Guid.Parse("00000000-0000-0000-0000-000000000001");
        _mockCurrentUserService.Setup(x => x.UserId).Returns(userId);

        var query = new Query.GetOrdersByCustomerId(
            null,
            null,
            SortOrder.Ascending,
            0,
            10);

        // Act
        var result = await _handler.Handle(query, CancellationToken.None);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.NotNull(result.Value);
        Assert.Equal(2, result.Value.TotalCount);
        Assert.Equal(2, result.Value.Items.Count);
        Assert.Equal("John Doe", result.Value.Items.First().CustomerName);
    }

    [Fact]
    public async Task Handle_ReturnsEmptyList_WhenCustomerHasNoOrders()
    {
        // Arrange
        var userId = Guid.Parse("00000000-0000-0000-0000-000000000002"); // Different user ID
        _mockCurrentUserService.Setup(x => x.UserId).Returns(userId);

        var query = new Query.GetOrdersByCustomerId(
            null,
            null,
            SortOrder.Ascending,
            0,
            10);

        // Act
        var result = await _handler.Handle(query, CancellationToken.None);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.NotNull(result.Value);
        Assert.Equal(0, result.Value.TotalCount);
        Assert.Empty(result.Value.Items);
    }

    [Fact]
    public async Task Handle_SearchesByDateRange_WhenSearchTermContainsValidDates()
    {
        // Arrange
        var userId = Guid.Parse("00000000-0000-0000-0000-000000000001");
        _mockCurrentUserService.Setup(x => x.UserId).Returns(userId);

        // Create a date range that includes today but not yesterday
        var today = DateOnly.FromDateTime(DateTime.Today);
        var yesterday = today.AddDays(-1);

        var query = new Query.GetOrdersByCustomerId(
            $"{today:yyyy-MM-dd} to {today:yyyy-MM-dd}",
            null,
            SortOrder.Ascending,
            0,
            10);

        // Act
        var result = await _handler.Handle(query, CancellationToken.None);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.NotNull(result.Value);
        Assert.Equal(1, result.Value.TotalCount); // Only one order from today
        Assert.Equal("Haircut", result.Value.Items.First().ServiceName);
    }

    [Fact]
    public async Task Handle_SearchesByPriceRange_WhenSearchTermContainsValidPrices()
    {
        // Arrange
        var userId = Guid.Parse("00000000-0000-0000-0000-000000000001");
        _mockCurrentUserService.Setup(x => x.UserId).Returns(userId);

        var query = new Query.GetOrdersByCustomerId(
            "80 to 100", // Price range that includes only the $90 final amount
            null,
            SortOrder.Ascending,
            0,
            10);

        // Act
        var result = await _handler.Handle(query, CancellationToken.None);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.NotNull(result.Value);
        Assert.Equal(1, result.Value.TotalCount);
        Assert.Equal(90, result.Value.Items.First().FinalAmount);
    }

    [Fact]
    public async Task Handle_SortsByTotalAmount_WhenSortColumnIsTotalAmount()
    {
        // Arrange
        var userId = Guid.Parse("00000000-0000-0000-0000-000000000001");
        _mockCurrentUserService.Setup(x => x.UserId).Returns(userId);

        var query = new Query.GetOrdersByCustomerId(
            null,
            "total amount",
            SortOrder.Ascending,
            0,
            10);

        // Act
        var result = await _handler.Handle(query, CancellationToken.None);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.NotNull(result.Value);
        Assert.Equal(2, result.Value.TotalCount);
        // Check if sorted by total amount ascending
        Assert.Equal(50, result.Value.Items.First().TotalAmount);
        Assert.Equal(100, result.Value.Items.Last().TotalAmount);
    }

    [Fact]
    public async Task Handle_SortsByDiscount_WhenSortColumnIsDiscount()
    {
        // Arrange
        var userId = Guid.Parse("00000000-0000-0000-0000-000000000001");
        _mockCurrentUserService.Setup(x => x.UserId).Returns(userId);

        var query = new Query.GetOrdersByCustomerId(
            null,
            "discount",
            SortOrder.Ascending,
            0,
            10);

        // Act
        var result = await _handler.Handle(query, CancellationToken.None);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.NotNull(result.Value);
        Assert.Equal(2, result.Value.TotalCount);
        // Check if sorted by discount ascending
        Assert.Equal(5, result.Value.Items.First().Discount);
        Assert.Equal(10, result.Value.Items.Last().Discount);
    }

    [Fact]
    public async Task Handle_SortsByFinalAmount_WhenSortColumnIsFinalAmount()
    {
        // Arrange
        var userId = Guid.Parse("00000000-0000-0000-0000-000000000001");
        _mockCurrentUserService.Setup(x => x.UserId).Returns(userId);

        var query = new Query.GetOrdersByCustomerId(
            null,
            "final amount",
            SortOrder.Ascending,
            0,
            10);

        // Act
        var result = await _handler.Handle(query, CancellationToken.None);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.NotNull(result.Value);
        Assert.Equal(2, result.Value.TotalCount);
        // Check if sorted by final amount ascending
        Assert.Equal(45, result.Value.Items.First().FinalAmount);
        Assert.Equal(90, result.Value.Items.Last().FinalAmount);
    }

    [Fact]
    public async Task Handle_SortsDescending_WhenSortOrderIsDescending()
    {
        // Arrange
        var userId = Guid.Parse("00000000-0000-0000-0000-000000000001");
        _mockCurrentUserService.Setup(x => x.UserId).Returns(userId);

        var query = new Query.GetOrdersByCustomerId(
            null,
            "total amount",
            SortOrder.Descending,
            0,
            10);

        // Act
        var result = await _handler.Handle(query, CancellationToken.None);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.NotNull(result.Value);
        Assert.Equal(2, result.Value.TotalCount);
        // Check if sorted by total amount descending
        Assert.Equal(100, result.Value.Items.First().TotalAmount);
        Assert.Equal(50, result.Value.Items.Last().TotalAmount);
    }

    // Fixed implementation of the mock DbSet
    private static Mock<DbSet<T>> CreateMockDbSet<T>(List<T> data) where T : class
    {
        var queryableData = data.AsQueryable();
        var mockDbSet = new Mock<DbSet<T>>();

        // Setup for synchronous operations - simpler approach that won't cause recursion
        mockDbSet.As<IQueryable<T>>().Setup(m => m.Provider).Returns(queryableData.Provider);
        mockDbSet.As<IQueryable<T>>().Setup(m => m.Expression).Returns(queryableData.Expression);
        mockDbSet.As<IQueryable<T>>().Setup(m => m.ElementType).Returns(queryableData.ElementType);
        mockDbSet.As<IQueryable<T>>().Setup(m => m.GetEnumerator()).Returns(() => queryableData.GetEnumerator());

        // Setup for Include() method - return the same mock to support chaining
        mockDbSet.Setup(m => m.Include(It.IsAny<string>())).Returns(mockDbSet.Object);

        return mockDbSet;
    }
}

================
File: BEAUTIFY_QUERY.APPLICATION/AssemblyReference.cs
================
using System.Reflection;

namespace BEAUTIFY_QUERY.APPLICATION;
public static class AssemblyReference
{
    public static readonly Assembly Assembly = typeof(AssemblyReference).Assembly;
}

================
File: BEAUTIFY_QUERY.APPLICATION/BEAUTIFY_QUERY.APPLICATION.csproj
================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="AutoMapper.Extensions.Microsoft.DependencyInjection" Version="12.0.1" />
        <PackageReference Include="BEAUTIFY_PACKAGES.SHARE" Version="1.12.6" />
        <PackageReference Include="FluentValidation" Version="11.10.0" />
        <PackageReference Include="FluentValidation.DependencyInjectionExtensions" Version="11.10.0" />
        <PackageReference Include="MediatR" Version="12.4.1" />
        <PackageReference Include="Microsoft.AspNetCore.Http" Version="2.3.0" />
        <PackageReference Include="Microsoft.Extensions.Caching.Abstractions" Version="8.0.0" />
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\BEAUTIFY_QUERY.PERSISTENCE\BEAUTIFY_QUERY.PERSISTENCE.csproj" />
    </ItemGroup>

    <ItemGroup>
        <PackageVersion Update="BEAUTIFY_PACKAGES.SHARE" Version="1.6.0" />
    </ItemGroup>


</Project>

================
File: BEAUTIFY_QUERY.APPLICATION/DependencyInjection/Extensions/AddMediatRApplication.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.APPLICATION.Behaviors;
using BEAUTIFY_QUERY.APPLICATION.Mapper;
using FluentValidation;
using MediatR;
using Microsoft.Extensions.DependencyInjection;

namespace BEAUTIFY_QUERY.APPLICATION.DependencyInjection.Extensions;
public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddMediatRApplication(this IServiceCollection services)
    {
        return services.AddMediatR(cfg =>
                cfg.RegisterServicesFromAssembly(AssemblyReference.Assembly)
            )
            // .AddTransient(typeof(IPipelineBehavior<,>), typeof(ValidationDefaultBehavior<,>))
            .AddTransient(typeof(IPipelineBehavior<,>), typeof(ValidationPipelineBehavior<,>))
            .AddTransient(typeof(IPipelineBehavior<,>), typeof(PerformancePipelineBehavior<,>))
            .AddTransient(typeof(IPipelineBehavior<,>), typeof(CachingPipelineBehaviorCachingBehavior<,>))
            .AddTransient(typeof(IPipelineBehavior<,>), typeof(TracingPipelineBehavior<,>))
            .AddValidatorsFromAssembly(CONTRACT.AssemblyReference.Assembly, includeInternalTypes: true);
    }

    public static IServiceCollection AddAutoMapperApplication(this IServiceCollection services)
    {
        return services.AddAutoMapper(typeof(ServiceProfile));
    }
}

================
File: BEAUTIFY_QUERY.APPLICATION/Exceptions/ValidationException.cs
================
using BEAUTIFY_QUERY.DOMAIN.Exceptions;

namespace BEAUTIFY_QUERY.APPLICATION.Exceptions;
public sealed class ValidationException : DomainException
{
    public ValidationException(IReadOnlyCollection<ValidationError> errors)
        : base("Validation Failure", "One or more validation errors occurred")
    {
        Errors = errors;
    }

    public IReadOnlyCollection<ValidationError> Errors { get; }
}

public record ValidationError(string PropertyName, string ErrorMessage);

================
File: BEAUTIFY_QUERY.APPLICATION/GlobalUsings.cs
================
// Global using directives

global using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Abstractions.Messages;
global using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Abstractions.Shared;
global using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Repositories;
global using BEAUTIFY_QUERY.DOMAIN.Documents;
global using BEAUTIFY_QUERY.DOMAIN.Entities;

================
File: BEAUTIFY_QUERY.APPLICATION/Mapper/ServiceProfile.cs
================
using AutoMapper;
using BEAUTIFY_QUERY.CONTRACT.Services.Subscriptions;

namespace BEAUTIFY_QUERY.APPLICATION.Mapper;
public class ServiceProfile : Profile
{
    public ServiceProfile()
    {
        CreateMap<SubscriptionPackage, Response.GetSubscriptionResponse>()
            .ForMember(dest => dest.PriceBranchAddition,
                opt => opt.MapFrom(src => src.PriceMoreBranch))
            .ForMember(dest => dest.PriceLiveStreamAddition,
                opt => opt.MapFrom(src => src.PriceMoreLivestream));

        CreateMap<PagedResult<SubscriptionPackage>, PagedResult<Response.GetSubscriptionResponse>>();


        // CreateMap<ClinicOnBoardingRequest, CONTRACT.Services.Clinics.Response.GetApplyRequest>()
        //     .ForMember(dest => dest.Id,
        //         opt 
        //             => opt.MapFrom(src => src.Id))
        //     .ForMember(dest => dest.Name,
        //         opt 
        //             => opt.MapFrom(src => src.Clinic!.Name))
        //     .ForMember(dest => dest.Email,
        //         opt 
        //             => opt.MapFrom(src => src.Clinic!.Email))
        //     .ForMember(dest => dest.Address,
        //         opt 
        //             => opt.MapFrom(src => src.Clinic!.Address))
        //     .ForMember(dest => dest.TotalApply,
        //         opt 
        //             => opt.MapFrom(src => src.Clinic!.TotalApply));
        //
        // CreateMap<List<ClinicOnBoardingRequest>, List<CONTRACT.Services.Clinics.Response.GetApplyRequest>>();
        //
        // CreateMap<PagedResult<ClinicOnBoardingRequest>, PagedResult<CONTRACT.Services.Clinics.Response.GetApplyRequest>>()
        //     .ForMember(dest => dest.Items, opt => opt.MapFrom(src => src.Items));


        // ==================SkillMapping=====================
        // CreateMap<Skill, SkillResponse.GetSkillsQuery>().ReverseMap();
        //
        // CreateMap<PagedResult<Skill>, PagedResult<SkillResponse.GetSkillsQuery>>()
        //     .ForMember(dest => dest.Items, opt => opt.MapFrom(src => src.Items));
        //
        // // ==================MentorMapping=====================
        // CreateMap<MentorProjection, Response.GetMentorResponse>()
        //     .ForMember(dest => dest.Id, opt => opt.MapFrom(src => src.DocumentId))
        //     .ConstructUsing((src, context) => new Response.GetMentorResponse
        //     {
        //         Email = src.Email,
        //         Point = src.Points,
        //         FullName = src.FullName,
        //         CreatedOnUtc = src.CreatedOnUtc,
        //         Skills = src.MentorSkills == null
        //             ? []
        //             : src.MentorSkills.Select(s => new Response.Skill
        //             {
        //                 SkillName = s.Name,
        //                 SkillDesciption = s.Description,
        //                 CreatedOnUtc = s.CreatedOnUtc,
        //                 SkillCategoryType = s.CateogoryType,
        //                 Cetificates = s.SkillCetificates.Select(c => new Response.Cetificate
        //                 {
        //                     CetificateName = c.Name,
        //                     CetificateImageUrl = c.ImageUrl,
        //                     CetificateDesciption = c.Description,
        //                     CreatedOnUtc = c.CreatedOnUtc
        //                 }).ToList()
        //             }).ToList()
        //     });
        //
        // CreateMap<MentorProjection, Response.GetAllMentorsResponse>()
        //     .ForMember(dest => dest.Id, opt => opt.MapFrom(src => src.DocumentId))
        //     .ConstructUsing((src, context) => new Response.GetAllMentorsResponse
        //     {
        //         Email = src.Email,
        //         Point = src.Points,
        //         FullName = src.FullName,
        //         CreatedOnUtc = src.CreatedOnUtc,
        //         Skills = src.MentorSkills == null ? [] : src.MentorSkills.Select(s => s.Name).ToList()
        //     });
        //
        // CreateMap<PagedResult<MentorProjection>, PagedResult<Response.GetAllMentorsResponse>>()
        //     .ConstructUsing((src, context) =>
        //     {
        //         var mappedItems = src.Items.Select(item => context.Mapper.Map<Response.GetAllMentorsResponse>(item))
        //             .ToList();
        //         return new PagedResult<Response.GetAllMentorsResponse>(mappedItems, src.PageIndex, src.PageSize,
        //             src.TotalCount);
        //     });
        //
        // CreateMap<Subject, Contract.Services.Subjects.Response.GetSubjectsQuery>().ReverseMap();
        // CreateMap<PagedResult<Subject>, PagedResult<Contract.Services.Subjects.Response.GetSubjectsQuery>>()
        //     .ForMember(dest => dest.Items, opt => opt.MapFrom(src => src.Items));
    }
}

================
File: BEAUTIFY_QUERY.APPLICATION/UseCases/PostgreMigrate/PostgreMigrateEventHandler.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Services.CommandConverts;
using BEAUTIFY_QUERY.PERSISTENCE;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;

namespace BEAUTIFY_QUERY.APPLICATION.UseCases.PostgreMigrate;
public class PostgreMigrateEventHandler : ICommandHandler<DomainEvents.PostgreMigrate>
{
    private readonly ApplicationDbContext _dbContext;
    private readonly ILogger<PostgreMigrateEventHandler> _logger;

    public PostgreMigrateEventHandler(ApplicationDbContext dbContext, ILogger<PostgreMigrateEventHandler> logger)
    {
        _dbContext = dbContext;
        _logger = logger;
    }

    public async Task<Result> Handle(DomainEvents.PostgreMigrate request, CancellationToken cancellationToken)
    {
        _logger.LogInformation(
            $"🔄 Processing {request.Operation} for entity {request.EntityType} with ID: {request.PrimaryKey}");

        var entityType = _dbContext.Model.GetEntityTypes()
            .Select(e => e.ClrType)
            .FirstOrDefault(t => t.Name.EndsWith(request.EntityType));

        if (entityType == null)
        {
            _logger.LogError($"❌ Unknown entity type: {request.EntityType}");
            return Result.Failure(new Error("500", $"❌ Unknown entity type: {request.EntityType}"));
        }

        var entity = JsonConvert.DeserializeObject(request.Data, entityType);
        if (entity == null)
        {
            _logger.LogError($"❌ Failed to deserialize entity {request.EntityType}");
            return Result.Failure(new Error("500", $"❌ Failed to deserialize entity {request.EntityType}"));
        }

        var entitySet = _dbContext.GetType()
            .GetMethod("Set")!
            .MakeGenericMethod(entityType)
            .Invoke(_dbContext, null);

        if (entitySet == null)
        {
            _logger.LogError($"❌ Could not retrieve DbSet for entity {request.EntityType}");
            return Result.Failure(new Error("500", $"❌ Could not retrieve DbSet for entity {request.EntityType}"));
        }

        switch (request.Operation)
        {
            case "Created":
                entitySet.GetType().GetMethod("Add")!.Invoke(entitySet, new[] { entity });
                break;

            case "Updated":
                var existing = await _dbContext.FindAsync(entityType, request.PrimaryKey, cancellationToken);
                if (existing != null)
                {
                    _dbContext.Entry(existing).CurrentValues.SetValues(entity);
                }
                else
                {
                    _logger.LogWarning(
                        $"⚠️ Entity {request.EntityType} with ID {request.PrimaryKey} not found for update. Creating new entry.");
                    entitySet.GetType().GetMethod("Add")!.Invoke(entitySet, new[] { entity });
                }

                break;

            case "Deleted":
                var toDelete = await _dbContext.FindAsync(entityType, request.PrimaryKey, cancellationToken);
                if (toDelete != null)
                    entitySet.GetType().GetMethod("Remove")!.Invoke(entitySet, new[] { toDelete });
                else
                    _logger.LogWarning(
                        $"⚠️ Entity {request.EntityType} with ID {request.PrimaryKey} not found for deletion.");
                break;
        }

        await _dbContext.SaveChangesAsync(cancellationToken);
        _logger.LogInformation($"✅ Successfully processed {request.Operation} for {request.EntityType}");

        return Result.Success();
    }
}

================
File: BEAUTIFY_QUERY.CONTRACT/AssemblyReference.cs
================
using System.Reflection;

namespace BEAUTIFY_QUERY.CONTRACT;
public static class AssemblyReference
{
    public static readonly Assembly Assembly = typeof(AssemblyReference).Assembly;
}

================
File: BEAUTIFY_QUERY.CONTRACT/BEAUTIFY_QUERY.CONTRACT.csproj
================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="BEAUTIFY_PACKAGES.SHARE" Version="1.12.6" />
    </ItemGroup>

    <ItemGroup>
        <PackageVersion Update="BEAUTIFY_PACKAGES.SHARE" Version="1.6.0" />
    </ItemGroup>

</Project>

================
File: BEAUTIFY_QUERY.CONTRACT/GlobalUsings.cs
================
// Global using directives

global using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Abstractions.Messages;
global using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Abstractions.Shared;

================
File: BEAUTIFY_QUERY.CONTRACT/Services/Booking/Query.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Enumerations;

namespace BEAUTIFY_QUERY.CONTRACT.Services.Booking;
public static class Query
{
    public record GetBookingPagedResult(
        string? searchTerm,
        string? SortColumn,
        SortOrder SortOrder,
        int PageNumber,
        int PageSize) : IQuery<PagedResult<Response.GetBookingResponse>>;

    public record GetBookingDetailById(Guid Id) : IQuery<Response.GetBookingDetailByIdResponse>;

    public record GetTotalAppointment(string date) : IQuery<Response.GetTotalAppointmentResponse>;

    public record GetBookingWithDate(string Date) : IQuery<Response.GetBookingWithDateResponse>;
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/Booking/Response.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.Booking;
public static class Response
{
    public record GetBookingResponse(
        Guid Id,
        string CustomerName,
        TimeSpan? Start,
        TimeSpan? End,
        string ServiceName,
        Guid ProcedureId,
        string StepIndex,
        string Name,
        int Duration,
        DateOnly? DateCompleted,
        string Status,
        DateOnly? date);

    public record GetBookingDetailByIdResponse
    {
        public Guid Id { get; init; }
        public string CustomerName { get; init; }
        public DateOnly? Date { get; init; }
        public TimeSpan? StartTime { get; init; }
        public TimeSpan? EndTime { get; init; }
        public string Duration { get; init; }
        public string DoctorNote { get; init; }
        public string Status { get; init; }
        public ServiceResponse Service { get; init; }
        public DoctorResponse Doctor { get; init; }
        public ClinicResponse Clinic { get; init; }
        public List<ProcedureHistory> ProcedureHistory { get; init; }
    }

    public record ProcedureHistory
    {
        public required string ProcedureName { get; init; }
        public string StepIndex { get; init; }
        public string ProcedurePriceType { get; init; }
        public int Duration { get; init; }
        public DateOnly? DateCompleted { get; init; }
        public TimeSpan? TimeCompleted { get; init; }
        public string Status { get; init; }
    }

    public class ProcedurePriceTypeEntity
    {
        public DateOnly? DateCompleted;
        public int Duration;
        public Guid Id;
        public string Name;
        public string StepIndex;
    }

    public record GetTotalAppointmentResponse
    {
        public string Month { get; init; }
        public List<DayCount> Days { get; init; }

        public record DayCount
        {
            public string? Date { get; init; }
            public CountDetails Counts { get; init; }
        }

        public record CountDetails
        {
            public int Total { get; init; }
            public int Completed { get; init; }
            public int InProgress { get; init; }
            public int Pending { get; init; }
            public int Cancelled { get; init; }
        }
    }

    public class GetBookingWithDateResponse
    {
        public string Date { get; set; }
        public List<AppointmentResponse> Appointments { get; set; }
    }

    public class AppointmentResponse
    {
        public Guid Id { get; set; }
        public CustomerResponse Customer { get; set; }
        public ServiceResponse Service { get; set; }
        public TimeSpan? StartTime { get; set; }
        public TimeSpan? EndTime { get; set; }
        public string Duration { get; set; }
        public string Status { get; set; }
        public DoctorResponse Doctor { get; set; }
        public ClinicResponse Clinic { get; set; }
    }

    public class CustomerResponse
    {
        public Guid? Id { get; set; }
        public string Name { get; set; }
        public string Avatar { get; set; }
    }

    public class ServiceResponse
    {
        public Guid? Id { get; set; }
        public string Name { get; set; }

        public ICollection<string> ImageUrls { get; set; }
    }

    public class DoctorResponse
    {
        public Guid? Id { get; set; }
        public string Name { get; set; }
        public string ImageUrl { get; set; }
    }

    public class ClinicResponse
    {
        public Guid? Id { get; set; }
        public string Name { get; set; }
        public string ImageUrl { get; set; }
    }
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/Categories/Query.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.Categories;
public class Query
{
    public record GetAllCategoriesQuery : IQuery<List<Response.GetAllCategories>>;

    public record GetAllCategoriesPagingQuery(string? searchTerm, int PageIndex, int PageSize)
        : IQuery<PagedResult<Response.GetAllCategories>>;

    public record GetCategoryByIdQuery(Guid Id) : IQuery<Response.GetAllCategoriesWithSubCategories>;
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/Categories/Response.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.Categories;
public class Response
{
    public record GetAllCategories(
        Guid Id,
        string Name,
        string Description,
        bool IsParent,
        Guid? ParentId,
        bool IsDeleted
    );

    public record GetAllCategoriesWithSubCategories(
        Guid Id,
        string Name,
        string Description,
        bool IsParent,
        Guid? ParentId,
        bool IsDeleted,
        List<GetAllCategories> SubCategories
    );
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/Clinics/Query.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Enumerations;

namespace BEAUTIFY_QUERY.CONTRACT.Services.Clinics;
public static class Query
{
    public enum Roles
    {
        DOCTOR = 1,
        CLINIC_STAFF = 2
    }

    public record GetClinicsQuery(
        string? SearchTerm,
        string? Role,
        string? SortColumn,
        SortOrder? SortOrder,
        int PageIndex,
        int PageSize) : IQuery<PagedResult<Response.GetClinics>>;

    public record GetClinicDetailQuery(
        Guid id,
        string? SearchTerm,
        string? SortColumn,
        SortOrder? SortOrder,
        int PageIndex,
        int PageSize) : IQuery<Response.GetClinicDetail>;
    
    public record GetClinicMyQuery(
        Guid ClinicId,
        string RoleName) : IQuery<Response.MyClinicApply>;

    public record GetAllApplyRequestQuery(int PageIndex, int PageSize) : IQuery<PagedResult<Response.GetApplyRequest>>;
    
    public record GetAllApplyBranchRequestQuery(Guid? ClinicId, string? SearchTerm, int PageIndex, int PageSize) : IQuery<PagedResult<Response.BranchClinicApplyGetAll>>;

    public record GetDetailApplyRequestQuery(Guid ApplyRequestId) : IQuery<Response.GetApplyRequestById>;
    
    public record GetDetailBranchApplyRequestQuery(Guid ApplyRequestId) : IQuery<Response.BranchClinicApplyDetail>;
    
    public record GetAllAccountOfEmployeeQuery(
        Guid ClinicId,
        Roles? Role,
        string? SearchTerm,
        int PageIndex,
        int PageSize)
        : IQuery<PagedResult<Response.GetAccountOfEmployee>>;

    public record GetDetailAccountOfEmployeeQuery(Guid ClinicId, Guid StaffId)
        : IQuery<Response.GetAccountOfEmployee>;

    public record GetAllClinicBranchQuery(
        string? SearchTerm,
        string? SortColumn,
        SortOrder? SortOrder,
        int PageIndex,
        int PageSize) : IQuery<PagedResult<Response.GetClinicBranches>>;

    public record GetClinicBranchesQuery(Guid? Id, string Role) : IQuery<Response.GetClinicBranchesResponse>;

    public record GetClinicByIdQuery(Guid Id) : IQuery<Response.ClinicBranchDto>;

    public record GetSubClinicByIdQuery(Guid Id) : IQuery<Response.ClinicBranchDto>;
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/Clinics/Response.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.Clinics;
public static class Response
{
    public class GetClinicBranchesResponse
    {
        public List<ClinicBranchDto> Clinics { get; set; } = new();
        public TotalSummaryDto Totals { get; set; } = new();
    }

    public class ClinicBranchDto
    {
        public Guid Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public string? Logo { get; set; }
        public decimal Balance { get; set; }
        public TimeSpan? WorkingTimeStart { get; set; }
        public TimeSpan? WorkingTimeEnd { get; set; }
        public string Email { get; set; }
        public string PhoneNumber { get; set; }
        public string? City { get; set; }
        public string? District { get; set; }
        public string? Ward { get; set; }
        public string? Address { get; set; }
        public string FullAddress => $"{Address}, {Ward}, {District}, {City}".Trim(',', ' ', '\n');
        public string TaxCode { get; set; }
        public string BusinessLicenseUrl { get; set; }
        public string OperatingLicenseUrl { get; set; }
        public DateTimeOffset? OperatingLicenseExpiryDate { get; set; }
        public decimal PendingWithdrawals { get; set; }

        public decimal TotalEarnings { get; set; }

        //bank account
        public string? BankName { get; set; } = string.Empty;
        public string? BankAccountNumber { get; set; } = string.Empty;
        public bool? IsMainClinic { get; set; } = false;
    }

    public class TotalSummaryDto
    {
        public decimal TotalBalance { get; set; }
        public decimal TotalPendingWithdrawals { get; set; }
        public decimal TotalEarnings { get; set; }
    }

    public record GetClinics(
        Guid Id,
        string Name,
        string Email,
        string FullAddress,
        int TotalBranches,
        string ProfilePictureUrl,
        bool IsActivated);

    public record GetClinicBranches(
        Guid Id,
        string Name,
        string Email,
        string? City,
        string? Address,
        string? District,
        string? Ward,
        string? FullAddress,
        string TaxCode,
        TimeSpan? WorkingTimeStart,
        TimeSpan? WorkingTimeEnd,
        string BusinessLicenseUrl,
        string OperatingLicenseUrl,
        DateTimeOffset? OperatingLicenseExpiryDate,
        string? ProfilePictureUrl,
        bool IsActivated);

    public record GetClinicDetail(
        Guid Id,
        string Name,
        string Email,
        string PhoneNumber,
        string? City,
        string? Address,
        string? District,
        string? Ward,
        string? FullAddress,
        int BranchLimit,
        int LivestreamLimit,
        string TaxCode,
        string BusinessLicenseUrl,
        string OperatingLicenseUrl,
        TimeSpan? WorkingTimeStart,
        TimeSpan? WorkingTimeEnd,
        DateTimeOffset? OperatingLicenseExpiryDate,
        string? ProfilePictureUrl,
        int TotalBranches,
        bool IsActivated,
        string BankName,
        string BankAccountNumber,
        Subscription? currentSubscription = null,
        PagedResult<GetClinicDetail>? Branches = null,
        List<Services.Response.GetAllServiceInGetClinicById>? Services = null);

    public class MyClinicApply
    {
        public string Name { get; set; }
        public string Email { get; set; }
        public string PhoneNumber { get; set; }
        public string City { get; set; }
        public string District { get; set; }
        public string Ward { get; set; }
        public string Address { get; set; }
        public string TaxCode { get; set; }
        public string BankName { get; set; }
        public string BankAccountNumber { get; set; }
        public string BusinessLicense { get; set; }
        public string OperatingLicense { get; set; }
        public DateTimeOffset OperatingLicenseExpiryDate { get; set; }
        public string ProfilePictureUrl { get; set; }
        public string RejectReason { get; set; }
    }

    public record Subscription(
        Guid Id,
        string Name,
        string Description,
        decimal Price,
        int Duration,
        bool IsActivated,
        int LimitBranch,
        int LimitLiveStream,
        DateOnly DateBought,
        DateOnly DateExpired,
        int DaysLeft);

    public record GetApplyRequest(
        Guid Id,
        string Name,
        string Email,
        string? FullAddress,
        int TotalApply,
        DateTimeOffset DateApplied);

    public class BranchClinicApplyGetAll
    {
        public Guid Id { get; set; }
        public string Name { get; set; }
        public DateTimeOffset CreatedOnUtc { get; set; }

        public Guid ParentId { get; set; }
        public string ParentName { get; set; }
        public string ParentEmail { get; set; }
        public string ParentPhoneNumber { get; set; }
        public string ParentCity { get; set; }
        public string ParentDistrict { get; set; }
        public string ParentWard { get; set; }
        public string ParentAddress { get; set; }

        public string? RejectReason { get; set; }
    }

    public class BranchClinicApplyDetail
    {
        public Guid Id { get; set; }
        public string Name { get; set; }
        public DateTimeOffset CreatedOnUtc { get; set; }
        public string Email { get; set; }
        public string PhoneNumber { get; set; }
        public string City { get; set; }
        public string District { get; set; }
        public string Ward { get; set; }
        public string FullAddress { get; set; }
        public TimeSpan? WorkingTimeStart { get; set; }
        public TimeSpan? WorkingTimeEnd { get; set; }
        public string Address { get; set; }
        public string TaxCode { get; set; }
        public string BankName { get; set; }
        public string BankAccountNumber { get; set; }
        public string BusinessLicenseUrl { get; set; }
        public string OperatingLicenseUrl { get; set; }
        public DateTimeOffset? OperatingLicenseExpiryDate { get; set; }
        public string ProfilePictureUrl { get; set; }

        public Guid ParentId { get; set; }
        public string ParentName { get; set; }
        public string ParentEmail { get; set; }
        public string ParentPhoneNumber { get; set; }
        public string ParentCity { get; set; }
        public string ParentDistrict { get; set; }
        public string ParentWard { get; set; }
        public string ParentAddress { get; set; }

        public string? RejectReason { get; set; }
    }

    public record GetApplyRequestById(
        Guid ApplyId,
        string Name,
        string Email,
        string PhoneNumber,
        string? City,
        string? Address,
        string? District,
        string? Ward,
        string? FullAddress,
        string TaxCode,
        string BusinessLicenseUrl,
        string OperatingLicenseUrl,
        DateTimeOffset? OperatingLicenseExpiryDate,
        string? ProfilePictureUrl,
        int TotalApply);

    public class GetAccountOfEmployee
    {
        public GetClinicBranches[] Branchs { get; set; }
        public Guid EmployeeId { get; set; }
        public string Email { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public string FullName { get; set; }
        public string? City { get; set; }
        public string? District { get; set; }
        public string? Ward { get; set; }
        public string? Address { get; set; }
        public string? PhoneNumber { get; set; }
        public string? FullAddress { get; set; }
        public string? ProfilePictureUrl { get; set; }
        public string? Role { get; set; }
        public List<DoctorCertificates>? DoctorCertificates { get; set; }
    }

    public class DoctorCertificates
    {
        public Guid Id { get; set; }
        public string CertificateUrl { get; set; }
        public string CertificateName { get; set; }
        public DateTimeOffset? ExpiryDate { get; set; }
        public string? Note { get; set; }
    }
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/CustomerSchedules/Query.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Enumerations;

namespace BEAUTIFY_QUERY.CONTRACT.Services.CustomerSchedules;
public static class Query
{
    public record StaffCheckInCustomerScheduleQuery(
        string CustomerName,
        string? CustomerPhone,
        int PageIndex = 1,
        int PageSize = 10)
        : IQuery<PagedResult<Response.StaffCheckInCustomerScheduleResponse>>;

    public record GetAllCustomerSchedule(
        string? SearchTerm,
        string? SortColumn,
        SortOrder? SortOrder,
        int PageIndex,
        int PageSize) : IQuery<PagedResult<Response.StaffCheckInCustomerScheduleResponse1>>;

    public record GetCustomerScheduleById(Guid Id, bool IsNext = false)
        : IQuery<Response.CustomerScheduleWithProceduresResponse>;

    public record GetAllCustomerBusyTime(Guid CustomerId, DateOnly Date)
        : IQuery<IReadOnlyList<Response.CustomerBusyTimeInADay>>;

    public record CheckIfNextCustomerScheduleIsNotScheduledYet(
        Guid CustomerScheduleId) : IQuery<string>;
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/CustomerSchedules/Response.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.CustomerSchedules;
public static class Response
{
    public record StaffCheckInCustomerScheduleResponse(
        Guid Id,
        Guid OrderId,
        decimal? ServicePrice,
        decimal? DiscountAmount,
        decimal DepositAmount,
        decimal? Amount,
        string CustomerName,
        string CustomerEmail,
        string? Note,
        string CustomerPhoneNumber,
        string ServiceName,
        string DoctorName,
        DateOnly? BookingDate,
        TimeSpan? StartTime,
        TimeSpan? EndTime,
        string Status,
        string ProcedurePriceTypeName,
        string ProcedureName,
        string StepIndex,
        bool IsFirstCheckIn = false);

    public record StaffCheckInCustomerScheduleResponse1(
        Guid Id,
        Guid OrderId,
        Guid UserId,
        decimal? ServicePrice,
        decimal? DiscountAmount,
        decimal DepositAmount,
        decimal Amount,
        string CustomerName,
        string CustomerEmail,
        string CustomerPhoneNumber,
        string ServiceName,
        string? DoctorNote,
        string DoctorName,
        DateOnly? BookingDate,
        TimeSpan? StartTime,
        TimeSpan? EndTime,
        string Status,
        string ProcedurePriceTypeName,
        string ProcedureName,
        string StepIndex,
        bool IsFirstCheckIn = false);

    public record CustomerScheduleWithProceduresResponse(
        // Basic customer information
        Guid Id,
        string CustomerName,
        string ServiceName,
        DateOnly? BookingDate,
        TimeSpan? StartTime,
        TimeSpan? EndTime,
        string Status,
        string DoctorNote,
        Guid DoctorId,

        // Current procedure details
        ProcedureDetailResponse CurrentProcedure);

    public record ProcedureDetailResponse(
        Guid Id,
        string Name,
        string StepIndex,
        DateOnly? Date);

    public record CustomerBusyTimeInADay(
        TimeSpan? Start,
        TimeSpan? End,
        DateOnly? Date
    );
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/Dashboards/Query.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.Dashboards;
public static class Query
{
    public record GetTotalInformationQuery(
        string RoleName,
        Guid ClinicId)
        : IQuery<Responses.GetTotalInformationResponse>;

    public record GetDaytimeInformationQuery(
        string RoleName,
        Guid ClinicId,
        DateOnly? StartDate,
        DateOnly? EndDate,
        bool? IsDisplayWeek,
        DateOnly? Date)
        : IQuery<Responses.GetDaytimeInformationResponse>;

    public record GetSystemTotalInformationQuery(
        string RoleName)
        : IQuery<Responses.GetSystemTotalInformationResponse>;

    public record GetSystemDaytimeInformationQuery(
        string RoleName,
        DateOnly? StartDate,
        DateOnly? EndDate,
        bool? IsDisplayWeek,
        DateOnly? Date)
        : IQuery<Responses.GetSystemDaytimeInformationResponse>;
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/Dashboards/Response.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.Dashboards;
public class Responses
{
    public class GetTotalInformationResponse
    {
        public int? TotalBranch { get; set; }
        public int? TotalBranchActive { get; set; }
        public int? TotalBranchInActive { get; set; }
        public int? TotalStaff { get; set; }
        public int TotalService { get; set; }
        public int TotalDoctor { get; set; }
    }

    public class GetSystemTotalInformationResponse
    {
        public int? TotalClinics { get; set; }
        public int? TotalBranding { get; set; }
        public int? TotalBranches { get; set; }
        public int? TotalBranchActive { get; set; }
        public int? TotalBranchInActive { get; set; }
        public int TotalBrandPending { get; set; }
        public int TotalService { get; set; }
        public int TotalDoctor { get; set; }
    }

    public class GetDaytimeInformationResponse
    {
        public Information? DatetimeInformation { get; set; }
        public List<DatetimeInformation>? DatetimeInformationList { get; set; }
    }

    public class Information
    {
        public int TotalCountOrderCustomer { get; set; }
        public int TotalCountScheduleCustomer { get; set; }
        public int TotalCountCustomerSchedule { get; set; }
        public int TotalCountCustomerSchedulePending { get; set; }
        public int TotalCountCustomerScheduleInProgress { get; set; }
        public int TotalCountCustomerScheduleCompleted { get; set; }
        public decimal TotalSumRevenue { get; set; }
        public int TotalCountOrderPending { get; set; }
        public decimal TotalSumRevenueNormal { get; set; }
        public decimal TotalSumRevenueLiveStream { get; set; }
    }

    public class DatetimeInformation
    {
        public Information Information { get; set; }
        public DateOnly StartDate { get; set; }
        public DateOnly EndDate { get; set; }
    }

    public class SystemInformation
    {
        public int TotalCountBranding { get; set; }
        public int TotalCountBranches { get; set; }
        public int TotalCountService { get; set; }
        public int TotalCountDoctor { get; set; }
        public int TotalCountBronzeSubscription { get; set; }
        public int TotalCountSilverSubscription { get; set; }
        public int TotalCountGoldSubscription { get; set; }
        public decimal TotalSumRevenue { get; set; }
        public decimal TotalSystemSumRevenue { get; set; }
        public decimal TotalSumBronzeSubscriptionRevenue { get; set; }
        public decimal TotalSumSilverSubscriptionRevenue { get; set; }
        public decimal TotalSumGoldSubscriptionRevenue { get; set; }
        public decimal TotalSumClinicRevenue { get; set; }
    }

    public class SystemDatetimeInformation
    {
        public SystemInformation Information { get; set; }
        public DateOnly StartDate { get; set; }
        public DateOnly EndDate { get; set; }
    }

    public class GetSystemDaytimeInformationResponse
    {
        public SystemInformation? SystemInformation { get; set; }
        public List<SystemDatetimeInformation>? SystemInformationList { get; set; }
    }
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/DoctorCertificates/Query.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Enumerations;

namespace BEAUTIFY_QUERY.CONTRACT.Services.DoctorCertificates;
public static class Query
{
    public record GetDoctorCertificateByDoctorId(Guid DoctorId)
        : IQuery<IReadOnlyList<Response.GetDoctorCertificateByResponse>>;

    public record GetDoctorCertificateById(Guid Id) : IQuery<Response.GetDoctorCertificateByResponse>;

    public record GetAllDoctorCertificates(
        string? searchTerm,
        string? SortColumn,
        SortOrder SortOrder,
        int PageNumber,
        int PageSize) : IQuery<PagedResult<Response.GetDoctorCertificateByResponse>>;
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/DoctorCertificates/Response.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.DoctorCertificates;
public static class Response
{
    public class GetDoctorCertificateByResponse
    {
        public Guid? Id { get; set; }
        public string DoctorName { get; set; }
        public string CertificateUrl { get; set; }
        public string CertificateName { get; set; }
        public DateTimeOffset? ExpiryDate { get; set; }
        public string? Note { get; set; }
    }
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/OrderDetails/Query.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.OrderDetails;
public static class Query
{
    public record GetOrderDetailsByOrderIdQuery(Guid OrderId) : IQuery<List<Response.OrderDetailResponse>>;
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/OrderDetails/Response.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.OrderDetails;
public static class Response
{
    public class OrderDetailResponse
    {
        public Guid Id { get; set; }
        public string? ProcedureName { get; set; }
        public string? ProcedurePriceType { get; set; }
        public decimal Price { get; set; }
        public int Duration { get; set; }
        public string? StepIndex { get; set; }
        public string? CustomerEmail { get; set; }
        public string? CustomerPhone { get; set; }
    }
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/Orders/Query.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Enumerations;

namespace BEAUTIFY_QUERY.CONTRACT.Services.Orders;
public static class Query
{
    public record GetOrdersByCustomerId(
        string? SearchTerm,
        string? SortColumn,
        SortOrder? SortOrder,
        int PageIndex,
        int PageSize) : IQuery<PagedResult<Response.Order>>;


    //Todo Check roles
    public record GetOrdersByClinicId(
        string? SearchTerm,
        string? SortColumn,
        SortOrder? SortOrder,
        int PageIndex,
        int PageSize) : IQuery<PagedResult<Response.Order>>;


    public record GetOrderById(Guid Id) : IQuery<Response.OrderById>;

    public record GetClinicOrderBranchesQuery(
        string? SearchTerm,
        string? SortColumn,
        SortOrder? SortOrder,
        int PageIndex,
        int PageSize) : IQuery<PagedResult<Response.Order>>;
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/Orders/Response.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.Orders;
public static class Response
{
    public record Order(
        Guid Id,
        string CustomerName,
        string ServiceName,
        decimal? TotalAmount,
        decimal? Discount,
        decimal? DepositAmount,
        decimal? FinalAmount,
        DateTimeOffset OrderDate,
        string Status,
        string CustomerPhone,
        string CustomerEmail,
        bool IsFromLivestream,
        string? LivestreamName
    );

    public record OrderById(
        Guid Id,
        string CustomerName,
        string ServiceName,
        decimal? TotalAmount,
        decimal? Discount,
        decimal? DepositAmount,
        decimal? FinalAmount,
        DateTimeOffset OrderDate,
        string Status,
        string CustomerPhone,
        string CustomerEmail,
        bool IsFromLivestream,
        bool IsFinished,
        string? LivestreamName,
        string? FeedbackContent,
        int? FeedbackRating,
        List<string>? FeedbackImages,
        List<CustomerSchedule> CustomerSchedules
    );

    public record CustomerSchedule(
        Guid Id,
        Guid DoctorId,
        string DoctorName,
        string ProcedureName,
        string ProfileUrl,
        string Status,
        DateOnly? Date,
        TimeSpan? StartTime,
        TimeSpan? EndTime,
        string? FeedbackContent,
        int? DoctorFeedbackRating,
        DateTimeOffset? FeedbackCreatedOnUtc);
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/Services/Query.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Enumerations;

namespace BEAUTIFY_QUERY.CONTRACT.Services.Services;
public static class Query
{
    public record GetServiceByClinicIdQuery(
        Guid ClinicId)
        : IQuery<List<Response.GetAllServiceByIdResponse>>;

    public record GetServiceByCategoryIdQuery(
        Guid CategoryId)
        : IQuery<List<Response.GetAllServiceByIdResponse>>;

    public record GetClinicServicesQuery(
        string? SearchTerm,
        string? SortColumn,
        SortOrder SortOrder,
        int PageNumber,
        int PageSize,
        Guid? MainClinicId)
        : IQuery<PagedResult<Response.GetAllServiceResponse>>;

    public record GetClinicServicesByIdQuery(Guid ServiceId, Guid? MainClinicId)
        : IQuery<Response.GetAllServiceByIdResponse>;
    
    public record GetDoctorClinicServicesByIdQuery(Guid ServiceId, int PageNumber,
        int PageSize): IQuery<PagedResult<Response.GetAllDoctorServiceByIdResponse>>;
    
    public record GetDoctorClinicServicesByIdQueryV2(Guid ServiceId): IQuery<Response.GetAllDoctorServiceByIdResponseV2>;

    public record GetAllServiceInGetClinicByIdQuery(
        int PageNumber,
        int PageSize)
        : IQuery<PagedResult<Response.GetAllServiceInGetClinicById>>;
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/Services/Response.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.Services;
public class Response
{
    public record GetAllServiceResponse(
        Guid Id,
        string Name,
        Clinic Branding,
        decimal MaxPrice,
        decimal MinPrice,
        double DepositPercent,
        bool IsRefundable,
        string DiscountPercent,
        decimal DiscountMaxPrice,
        decimal DiscountMinPrice,
        ICollection<Image> CoverImage,
        ICollection<Clinic> Clinics,
        Category Category,
        ICollection<DoctorService>? DoctorServices,
        ICollection<Feedback> Feedbacks);


    public record DoctorService(
        Guid Id,
        Guid ServiceId,
        UserEntity Doctor);

    public record UserEntity(
        Guid Id,
        string FullName,
        string Email,
        string PhoneNumber,
        string ProfilePictureUrl,
        ICollection<CertificateEntity> DoctorCertificates
    );
    
    public record DoctorService1(
        Guid Id,
        UserEntity Doctor,
        Clinic Clinic);

    //Final Test
    public record CertificateEntity
    {
        public Guid Id { get; set; }
        public string CertificateUrl { get; set; }
        public string CertificateName { get; set; }
        public DateTimeOffset? ExpiryDate { get; set; }
        public string? Note { get; set; }
    }

    public record Category(Guid Id, string Name, string Description);


    public record Clinic(
        Guid Id,
        string Name,
        string Email,
        string Address,
        string PhoneNumber,
        TimeSpan WorkingTimeStart,
        TimeSpan WorkingTimeEnd,
        string? ProfilePictureUrl,
        bool? IsParent,
        bool IsActivated,
        Guid? ParentId);

    public class GetAllServiceInGetClinicById
    {
        public Guid Id { get; set; }
        public string Name { get; set; }
        public string Description { get; set; }
        public decimal MaxPrice { get; set; }
        public decimal MinPrice { get; set; }
        public required double DepositPercent { get; set; }
        public required bool IsRefundable { get; set; }
        public string DiscountPercent { get; set; }
        public decimal DiscountMaxPrice { get; set; }
        public decimal DiscountMinPrice { get; set; }
        public ICollection<Image> CoverImage { get; set; }
    }

    public class Feedback
    {
        public Guid FeedbackId { get; set; }
        public Guid ServiceId { get; set; }
        public ICollection<string> Images { get; set; }
        public string Content { get; set; }
        public int Rating { get; set; }
        public User User { get; set; }
        public bool IsView { get; set; }
        public DateTimeOffset CreatedAt { get; set; }
        public DateTimeOffset? UpdatedAt { get; set; }
    }

    public class User
    {
        public Guid Id { get; set; }
        public string Avatar { get; set; }
        public string PhoneNumber { get; set; }
        public string FullName { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public string Address { get; set; }
    }


    public record GetAllServiceByIdResponse(
        Guid Id,
        string Name,
        string Description,
        Clinic Branding,
        decimal MaxPrice,
        decimal MinPrice,
        string DiscountPercent,
        decimal DiscountMaxPrice,
        decimal DiscountMinPrice,
        double DepositPercent,
        bool IsRefundable,
        ICollection<Image> CoverImage,
        ICollection<Clinic>? Clinics,
        Category Category,
        ICollection<Procedure> Procedures,
        ICollection<Promotion>? Promotions,
        ICollection<DoctorService>? DoctorServices,
        ICollection<Feedback> Feedbacks);
    
    public record GetAllDoctorServiceByIdResponse(
        Guid Id,
        UserEntity Doctor,
        Clinic Clinic);

    public record GetAllDoctorServiceByIdResponseV2(
        Guid Id,
        ICollection<DoctorService>? DoctorServices
    );

    public record Procedure(
        Guid Id,
        string Name,
        string Description,
        int StepIndex,
        ICollection<ProcedurePriceType> procedurePriceTypes
    );

    public record ProcedurePriceType(Guid Id, string Name, int Duration, decimal Price, bool IsDefault);

    public record Image(Guid Id, int Index, string Url);

    public record Promotion(
        Guid Id,
        string Name,
        double DiscountPercent,
        string ImageUrl,
        DateTimeOffset StartDay,
        DateTimeOffset EndDate,
        bool IsActivated);
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/ShiftConfigs/Query.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.ShiftConfigs;

public static class Query
{
    public record GetShiftConfigQuery(
        Guid ClinicId,
        string RoleName,
        int PageNumber,
        int PageSize)
        : IQuery<PagedResult<Response.ShiftResponse>>;
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/ShiftConfigs/Response.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.ShiftConfigs;

public class Response
{
    public record ShiftResponse(
        Guid Id,
        string Name,
        string? Note,
        TimeSpan StartTime,
        TimeSpan EndTime,
        DateTimeOffset CreatedAt);
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/Subscriptions/Query.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Enumerations;

namespace BEAUTIFY_QUERY.CONTRACT.Services.Subscriptions;
public static class Query
{
    public record GetSubscription(
        string? searchTerm,
        string? SortColumn,
        SortOrder SortOrder,
        int PageNumber,
        int PageSize) : IQuery<PagedResult<Response.GetSubscriptionResponse>>;

    public record GetSubscriptionById(Guid Id) : IQuery<Response.GetSubscriptionResponse>;
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/Subscriptions/Response.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.Subscriptions;
public static class Response
{
    public class GetSubscriptionResponse
    {
        public Guid? Id { get; set; }
        public string? Name { get; set; }
        public string? Description { get; set; }
        public decimal? Price { get; set; }
        public int Duration { get; set; }
        public bool IsActivated { get; set; }
        public int LimitBranch { get; set; }
        public int LimitLiveStream { get; set; }
        public decimal PriceBranchAddition { get; set; }
        public decimal PriceLiveStreamAddition { get; set; }
        public int EnhancedViewer { get; set; }
    }
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/SurveyQuestions/Query.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.SurveyQuestions;
public static class Query
{
    public record GetSurveyQuestionBySurveyId(Guid SurveyId, int PageIndex = 1, int PageSize = 10)
        : IQuery<PagedResult<Response.SurveyQuestionResponse>>;
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/SurveyQuestions/Response.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.SurveyQuestions;
public static class Response
{
    public class SurveyQuestionResponse
    {
        public Guid Id { get; set; }
        public string Question { get; set; }
        public string QuestionType { get; set; }
        public Guid? SurveyId { get; set; }
    }
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/Surveys/Query.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Enumerations;

namespace BEAUTIFY_QUERY.CONTRACT.Services.Surveys;
public static class Query
{
    public record GetSurvey(
        string? searchTerm,
        string? SortColumn,
        SortOrder SortOrder,
        int PageNumber,
        int PageSize) : IQuery<PagedResult<Response.SurveyResponse>>;
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/Surveys/Response.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.Surveys;
public static class Response
{
    public class SurveyResponse
    {
        public Guid Id { get; set; }
        public string Name { get; set; }
        public string Description { get; set; }
        public string CategoryName { get; set; }
        public List<SurveyQuestionResponse> Questions { get; set; }
    }

    public class SurveyQuestionResponse
    {
        public Guid Id { get; set; }
        public string Question { get; set; }
        public string QuestionType { get; set; }
        public List<SurveyQuestionOptionResponse> Options { get; set; }
    }

    public class SurveyQuestionOptionResponse
    {
        public string Option { get; set; }
    }
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/Users/Query.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.Users;
public class Query
{
    public record GetUserByPhoneOrEmail(string PhoneOrEmail) : IQuery<Response.GetUserByPhoneAndEmailResponse>;


    public record GetUserInformation : IQuery<Response.GetUserInformationResponse>;

    public record GetCustomerCurrentBalance(Guid UserId) : IQuery<string>;
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/Users/Response.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.Users;
public static class Response
{
    public record GetUserByPhoneAndEmailResponse(Guid Id);

    public record GetUserInformationResponse(
        Guid Id,
        string FirstName,
        string LastName,
        string FullName,
        DateOnly? DateOfBirth,
        string Email,
        string? Phone,
        string? ProfilePicture,
        string? City,
        string? District,
        string? Ward,
        string? Address,
        string? FullAddress,
        decimal? Balance = 0
    );
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/WalletTransactions/Query.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Enumerations;

namespace BEAUTIFY_QUERY.CONTRACT.Services.WalletTransactions;
public static class Query
{
    /// <summary>
    ///     Query to get wallet transactions for the current clinic
    /// </summary>
    public record GetClinicWalletTransactions(
        string? SearchTerm,
        string? SortColumn,
        SortOrder? SortOrder,
        int PageIndex,
        int PageSize) : IQuery<PagedResult<Response.WalletTransactionResponse>>;

    /// <summary>
    ///     Query to get wallet transactions for all sub-clinics of a parent clinic
    /// </summary>
    public record GetSubClinicWalletTransactions(
        string? SearchTerm,
        string? SortColumn,
        SortOrder? SortOrder,
        int PageIndex,
        int PageSize) : IQuery<PagedResult<Response.WalletTransactionResponse>>;

    /// <summary>
    ///     Query to get wallet transactions for all clinics (admin only)
    /// </summary>
    public record GetAllClinicWalletTransactions(
        string? SearchTerm,
        string? SortColumn,
        SortOrder? SortOrder,
        int PageIndex,
        int PageSize) : IQuery<PagedResult<Response.WalletTransactionResponse>>;

    /// <summary>
    ///     Query to get wallet transactions for a specific clinic by ID
    /// </summary>
    public record GetWalletHistoryByClinicId(
        Guid ClinicId,
        string? SearchTerm,
        string? SortColumn,
        SortOrder? SortOrder,
        int PageIndex,
        int PageSize) : IQuery<PagedResult<Response.WalletTransactionResponse>>;

    public record CustomerGetAllWalletTransactions(
        string? SearchTerm,
        string? SortColumn,
        SortOrder? SortOrder,
        int PageIndex,
        int PageSize) : IQuery<PagedResult<Response.WalletTransactionResponse>>;
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/WalletTransactions/Response.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.WalletTransactions;
public static class Response
{
    public record WalletTransactionResponse(
        Guid Id,
        Guid? ClinicId,
        string? ClinicName,
        decimal Amount,
        string TransactionType,
        string Status,
        bool IsMakeBySystem,
        string? NewestQrUrl,
        string? Description,
        DateTime TransactionDate,
        DateTimeOffset CreatedOnUtc);

    public record ClinicBasicInfo(
        Guid Id,
        string Name,
        string Email,
        string? PhoneNumber,
        string? Address,
        bool IsParent,
        bool IsActivated);
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/WorkingSchedules/Query.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Enumerations;

namespace BEAUTIFY_QUERY.CONTRACT.Services.WorkingSchedules;
public static class Query
{
    public record GetClinicWorkingHours(Guid ClinicId)
        : IQuery<Response.GetClinicWorkingHoursResponse>;

    public record GetWorkingScheduleEachDayInMonth(DateOnly Date)
        : IQuery<Response.GetWorkingScheduleEachDayInMonthResponse>;

    public record GetWorkingScheduleDaily(DateOnly Date)
        : IQuery<IReadOnlyList<Response.GetWorkingScheduleResponseDaily>>;

    public record GetWorkingScheduleDetail(Guid Id) : IQuery<Response.GetWorkingScheduleDetailResponse>;

    public record GetWorkingSchedule(
        string? searchTerm,
        string? SortColumn,
        SortOrder SortOrder,
        int PageNumber,
        int PageSize) : IQuery<PagedResult<Response.GetWorkingScheduleResponse>>;

    public record GetAllDoctorFreeTime(Guid DoctorId, Guid ClinicId, DateOnly Date)
        : IQuery<IReadOnlyList<Response.DoctorBusyTimeInADay>>;

    public record GetWorkingScheduleOfDoctorId(
        string? searchTerm,
        string? SortColumn,
        SortOrder SortOrder,
        int PageNumber,
        int PageSize) : IQuery<PagedResult<Response.ShiftGroup>>;

    public record GetWorkingScheduleByClinicId(
        string? searchTerm,
        string? SortColumn,
        SortOrder SortOrder,
        int PageNumber,
        int PageSize) : IQuery<PagedResult<Response.GetScheduleResponseForStaff>>;

    public record GetUnregisteredWorkingSchedules(
        Guid ClinicId,
        string searchTerm,
        string? SortColumn,
        SortOrder SortOrder,
        int PageNumber,
        int PageSize) : IQuery<PagedResult<Response.GetEmptyScheduleResponseWithId>>;

    public record GetDoctorAvailableTimeSlots(
        Guid serviceIdOrCustomerScheduleId,
        Guid? ClinicId,
        bool IsCustomerSchedule,
        Guid? DoctorId,
        DateOnly Date)
        : IQuery<IReadOnlyList<Response.GetEmptyScheduleResponse>>;

    public record GetSchedulesByShiftGroupId(
        Guid ShiftGroupId,
        string? SearchTerm,
        string? SortColumn,
        SortOrder SortOrder,
        int PageNumber,
        int PageSize) : IQuery<PagedResult<Response.GetWorkingScheduleResponse_Son>>;
}

================
File: BEAUTIFY_QUERY.CONTRACT/Services/WorkingSchedules/Response.cs
================
namespace BEAUTIFY_QUERY.CONTRACT.Services.WorkingSchedules;
public static class Response
{
    public class ShiftGroup
    {
        public Guid Id { get; set; }
        public TimeSpan StartTime { get; set; }
        public TimeSpan EndTime { get; set; }
        public DateOnly Date { get; set; }
        public Guid? DoctorId { get; set; }
        public string? DoctorName { get; set; }
        public Guid ClinicId { get; set; }
        public List<GetWorkingScheduleResponse> WorkingSchedules { get; set; } = [];
    }

    public class GetWorkingScheduleResponse_Son
    {
        public Guid WorkingScheduleId { get; set; }
        public TimeSpan StartTime { get; set; }
        public TimeSpan EndTime { get; set; }
        public Guid? DoctorId { get; set; }
        public string? DoctorName { get; set; }
        public DateOnly Date { get; set; }
       
    }

    public class GetWorkingScheduleResponse
    {
        public Guid WorkingScheduleId { get; set; }
        public TimeSpan StartTime { get; set; }
        public TimeSpan EndTime { get; set; }
        public string? Status { get; set; }
        public string StepIndex { get; set; }
        public string CustomerName { get; set; }
        public string Note { get; set; }
        public Guid? CustomerId { get; set; }
        public Guid? ServiceId { get; set; }
        public string ServiceName { get; set; }
        public Guid? CustomerScheduleId { get; set; }
        public string CurrentProcedureName { get; set; }
    }

    public class DoctorBusyTimeInADay
    {
        public TimeSpan? Start { get; set; }
        public TimeSpan? End { get; set; }
        public DateOnly? Date { get; set; }
    }

    public class GetWorkingScheduleEachDayInMonthResponse
    {
        public int Year { get; set; }
        public int Month { get; set; }
        public Dictionary<DateOnly, int> AppointmentCounts { get; set; } = new();
    }

    public class GetWorkingScheduleResponseDaily
    {
        public DateOnly Date { get; set; }
        public List<Appointment> Appointments { get; set; } = [];

        public class Appointment
        {
            public Guid Id { get; set; }
            public string CustomerName { get; set; }
            public string ServiceName { get; set; }
            public DateOnly Date { get; set; }
            public TimeSpan StartTime { get; set; }
            public TimeSpan EndTime { get; set; }
            public string StepIndex { get; set; }
            public string ProcedurePriceTypeName { get; set; }
            public string Duration { get; set; }
            public string Status { get; set; }
            public Guid? CustomerScheduleId { get; set; }
            public bool? IsNoted { get; set; }
            public string? Note { get; set; }
        }
    }

    public record GetEmptyScheduleResponse(
        DateOnly Date,
        TimeSpan StartTime,
        TimeSpan EndTime
    );

    public record GetEmptyScheduleResponseWithId(
        Guid WorkingScheduleId,
        DateOnly Date,
        TimeSpan StartTime,
        TimeSpan EndTime
    );


    public record GetScheduleResponseForStaff(
        Guid Id,
        Guid ShiftGroupId,
        int Capacity,
        int NumberOfDoctors,
        int NumberOfCustomers,
        DateOnly Date,
        TimeSpan StartTime,
        TimeSpan EndTime
    );

    public class GetWorkingScheduleDetailResponse
    {
        public GetWorkingScheduleResponseDaily.Appointment Appointment { get; set; } = new();
    }

    public class GetClinicWorkingHoursResponse
    {
        public TimeSpan StartTime { get; set; }
        public TimeSpan EndTime { get; set; }
    }
}

================
File: BEAUTIFY_QUERY.DOMAIN/BEAUTIFY_QUERY.DOMAIN.csproj
================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="BEAUTIFY_PACKAGES.SHARE" Version="1.12.6" />
    </ItemGroup>

    <ItemGroup>
      <ProjectReference Include="..\BEAUTIFY_QUERY.CONTRACT\BEAUTIFY_QUERY.CONTRACT.csproj" />
    </ItemGroup>

    <ItemGroup>
        <PackageVersion Update="BEAUTIFY_PACKAGES.SHARE" Version="1.6.0" />
    </ItemGroup>

</Project>

================
File: BEAUTIFY_QUERY.DOMAIN/Constanst.cs
================
namespace BEAUTIFY_QUERY.DOMAIN;
public static class ErrorMessages
{
    public static class Clinic
    {
        public const string ClinicNotFound = "Không tìm thấy phòng khám.";
        public const string ClinicIsNotABranch = "Phòng khám không phải là chi nhánh.";
        public const string ParentClinicNotFound = "Không tìm thấy phòng khám chi nhánh chính";

        public const string ParentClinicNotFoundOrChildren =
            "Không tìm thấy phòng khám chi nhánh chính hoặc không có chi nhánh nào";

        public const string AmountMustBeGreaterThan2000 = "Số tiền phải lớn hơn 2000";
        public const string InsufficientFunds = "Số dư không đủ";
        public const string ClinicAlreadyExists = "Clinic already exists.";
        public const string ClinicBranchNotFound = "Clinic branch not found.";
        public const string ClinicBranchAlreadyExists = "Clinic branch already exists.";
        public const string ClinicBranchNotActive = "Clinic branch is not active.";
    }

    public static class Service
    {
        public const string ServiceNotFound = "Không tìm thấy dịch vụ.";
        public const string ServiceAlreadyExists = "Dịch vụ đã tồn tại.";
        public const string ServiceNotActive = "Dịch vụ không hoạt động.";
        public const string ServiceAlreadyDeleted = "Dịch vụ đã bị xóa.";
        public const string ServiceNameAlreadyExists = "Tên dịch vụ đã tồn tại.";
    }

    public static class CustomerSchedule
    {
        public const string CustomerScheduleNotFound = "Không tìm thấy lịch hẹn của khách hàng.";
        public const string NextCustomerScheduleNotFound = "Không tìm thấy lịch hẹn tiếp theo của khách hàng.";
        public const string CustomerScheduleAlreadyExists = "Lịch hẹn của khách hàng đã tồn tại.";
        public const string CustomerScheduleNotActive = "Lịch hẹn của khách hàng không hoạt động.";
        public const string CustomerScheduleAlreadyCompleted = "Lịch hẹn của khách hàng đã hoàn thành.";
        public const string CustomerScheduleAlreadyCancelled = "Lịch hẹn của khách hàng đã bị hủy.";
    }

    public static class Wallet
    {
        public const string WalletNotFound = "Không tìm thấy ví.";
        public const string InsufficientBalance = "Insufficient balance.";
        public const string InvalidTransactionType = "Invalid transaction type.";
        public const string InvalidTransactionStatus = "Trạng thái giao dịch không hợp lệ.";
        public const string TransactionNotFound = "Transaction not found.";
        public const string TransactionAlreadyExists = "Transaction already exists.";
        public const string TransactionFailed = "Transaction failed.";
    }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Constrants/TableNames.cs
================
namespace BEAUTIFY_QUERY.DOMAIN.Constrants;
public static class TableNames
{
    internal const string SubscriptionPackage = nameof(SubscriptionPackage);
    internal const string Service = nameof(Service);
    internal const string WorkingSchedule = nameof(WorkingSchedule);
    internal const string CustomerSchedule = nameof(CustomerSchedule);
}

================
File: BEAUTIFY_QUERY.DOMAIN/Documents/ClinicServiceProjection.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Attributes;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.EntityEvents;
using BEAUTIFY_QUERY.DOMAIN.Constrants;

namespace BEAUTIFY_QUERY.DOMAIN.Documents;
[BsonCollection(TableNames.Service)]
public class ClinicServiceProjection : Document
{
    public string Name { get; set; }
    public string Description { get; set; }
    public ICollection<Image> CoverImage { get; set; }
    public Clinic Branding { get; set; }
    public ICollection<EntityEvent.DoctorServiceEntity> DoctorServices { get; set; } = [];
    public decimal DiscountPercent { get; set; } = 0;
    public required double DepositPercent { get; set; }
    public required bool IsRefundable { get; set; }
    public decimal MaxPrice { get; set; } = 0;
    public decimal MinPrice { get; set; } = 0;
    public decimal DiscountMaxPrice { get; set; } = 0;
    public decimal DiscountMinPrice { get; set; } = 0;
    public Category Category { get; set; }
    public ICollection<Clinic> Clinic { get; set; }
    public ICollection<Procedure> Procedures { get; set; } = Array.Empty<Procedure>();
    public ICollection<Promotion> Promotions { get; set; } = Array.Empty<Promotion>();
    public ICollection<Feedback> Feedbacks { get; set; } = Array.Empty<Feedback>();
}

public record Category(Guid Id, string Name, string Description);

public class Clinic
{
    public Guid Id { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
    public string City { get; set; }
    public string Address { get; set; }
    public string District { get; set; }
    public string Ward { get; set; }
    public string FullAddress { get; set; }
    public string PhoneNumber { get; set; }
    public required TimeSpan WorkingTimeStart { get; set; }
    public required TimeSpan WorkingTimeEnd { get; set; }
    public string? ProfilePictureUrl { get; set; }
    public bool? IsParent { get; set; }
    public bool IsActivated { get; set; }
    public Guid? ParentId { get; set; }
}

public class Procedure
{
    public Guid Id { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    public int StepIndex { get; set; }
    public ICollection<ProcedurePriceType> ProcedurePriceTypes { get; set; } = Array.Empty<ProcedurePriceType>();
}

public class Promotion
{
    public Guid Id { get; set; }
    public string Name { get; set; }
    public double DiscountPercent { get; set; }
    public string ImageUrl { get; set; }
    public DateTimeOffset StartDay { get; set; }
    public DateTimeOffset EndDate { get; set; }
    public bool IsActivated { get; set; }
}

public record ProcedurePriceType(Guid Id, string Name, decimal Price, int Duration, bool IsDefault);

public class Image
{
    public Guid Id { get; set; }
    public int Index { get; set; }
    public string Url { get; set; }
}

public class Feedback
{
    public Guid FeedbackId { get; set; }
    public Guid ServiceId { get; set; }
    public ICollection<string> Images { get; set; }
    public string Content { get; set; }
    public int Rating { get; set; }
    public User User { get; set; }
    public bool IsView { get; set; }
    public DateTimeOffset CreatedAt { get; set; }
    public DateTimeOffset? UpdatedAt { get; set; }
}

public class User
{
    public Guid Id { get; set; }
    public string Avatar { get; set; }
    public string PhoneNumber { get; set; }
    public string FullName { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string Address { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Documents/CustomerScheduleProjection.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Attributes;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.EntityEvents;
using BEAUTIFY_QUERY.DOMAIN.Constrants;

namespace BEAUTIFY_QUERY.DOMAIN.Documents;
[BsonCollection(TableNames.CustomerSchedule)]
public class CustomerScheduleProjection : Document
{
    public Guid? ClinicId;
    public string ClinicName;
    public EntityEvent.ProcedurePriceTypeEntity CurrentProcedure;
    public Guid? CustomerId;
    public string CustomerName;
    public DateOnly? Date;
    public Guid? DoctorId;
    public string? DoctorName;
    public string? DoctorNote;
    public TimeSpan? EndTime;
    public required Guid OrderId;
    public Guid? ServiceId;
    public string ServiceName;
    public TimeSpan? StartTime;
    public string Status;
}

================
File: BEAUTIFY_QUERY.DOMAIN/Documents/SubscriptionProjection.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Attributes;
using BEAUTIFY_QUERY.DOMAIN.Constrants;

namespace BEAUTIFY_QUERY.DOMAIN.Documents;
[BsonCollection(TableNames.SubscriptionPackage)]
public class SubscriptionProjection : Document
{
    public string Name { get; set; }
    public string Description { get; set; }
    public decimal Price { get; set; }
    public int Duration { get; set; }
    public bool IsDeleted { get; set; }
    public bool IsActivated { get; set; }
    public int LimitBranch { get; set; }
    public int LimitLiveStream { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Documents/WorkingScheduleProjection.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Attributes;
using BEAUTIFY_QUERY.DOMAIN.Constrants;

namespace BEAUTIFY_QUERY.DOMAIN.Documents;
[BsonCollection(TableNames.WorkingSchedule)]
public class WorkingScheduleProjection : Document
{
    public Guid? DoctorId { get; set; }
    public Guid? CustomerScheduleId { get; set; }
    public string? DoctorName { get; set; }
    public Guid ClinicId { get; set; }
    public DateOnly Date { get; set; }
    public TimeSpan StartTime { get; set; }
    public TimeSpan EndTime { get; set; }
    public bool IsDeleted { get; set; } = false;

    public string? Status { get; set; }
    public string? Note { get; set; }
    public bool? IsNoted { get; set; }

    public string? StepIndex { get; set; }
    public string? CustomerName { get; set; }
    public Guid? CustomerId { get; set; }

    public Guid? ServiceId { get; set; }
    public string? ServiceName { get; set; }
    public Guid? ShiftGroupId { get; set; }
    public int? ShiftCapacity { get; set; }

    public string? CurrentProcedureName { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/Category.cs
================
using System.ComponentModel.DataAnnotations;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class Category : AggregateRoot<Guid>, IAuditableEntity
{
    [MaxLength(100)] public required string Name { get; set; }
    [MaxLength(250)] public string? Description { get; set; }
    public bool IsParent { get; set; } = false;
    public Guid? ParentId { get; set; }
    public virtual Category? Parent { get; set; }

    public virtual ICollection<Category> Children { get; set; } = [];
    // public Guid? ClinicId { get; set; }
    // public virtual Clinic? Clinic { get; set; }

    public virtual ICollection<Service> Services { get; set; } = [];
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }

    //   public virtual ICollection<DoctorService>? DoctorServices { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/Clinic.cs
================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class Clinic : AggregateRoot<Guid>, IAuditableEntity
{
    [MaxLength(100)] public required string Name { get; set; }
    [MaxLength(100)] public required string Email { get; set; }
    [MaxLength(15)] public required string PhoneNumber { get; set; }
    [MaxLength(100)] public string? City { get; set; }
    [MaxLength(100)] public string? District { get; set; }
    [MaxLength(100)] public string? Ward { get; set; }
    [MaxLength(100)] public string? Address { get; set; }
    [MaxLength(250)] public string? FullAddress => $"{Address}, {Ward}, {District}, {City}".Trim(',', ' ', '\n');
    [MaxLength(20)] public required string TaxCode { get; set; }
    [MaxLength(250)] public required string BusinessLicenseUrl { get; set; }
    [MaxLength(250)] public required string OperatingLicenseUrl { get; set; }
    public DateTimeOffset? OperatingLicenseExpiryDate { get; set; }

    public int Status { get; set; } = 0;

    // 0 Pending, 1 Approve, 2 Reject, 3 Banned
    public int TotalApply { get; set; } = 0;
    [MaxLength(250)] public string? ProfilePictureUrl { get; set; }
    public int? TotalBranches { get; set; } = 0;
    public int AdditionBranches { get; set; } = 0;
    public int AdditionLivestreams { get; set; } = 0;
    public TimeSpan? WorkingTimeStart { get; set; }
    public TimeSpan? WorkingTimeEnd { get; set; }
    public bool IsActivated { get; set; } = false;
    public bool? IsParent { get; set; } = false;
    [MaxLength(255)] public string? BankName { get; set; }
    [MaxLength(100)] public string? BankAccountNumber { get; set; }
    [Column(TypeName = "decimal(18,2)")] public decimal Balance { get; set; }
    public Guid? ParentId { get; set; }
    public virtual Clinic? Parent { get; set; }
    [MaxLength(250)] public string? Note { get; set; }
    public virtual ICollection<Clinic> Children { get; set; } = [];
    public virtual ICollection<ClinicOnBoardingRequest>? ClinicOnBoardingRequests { get; set; }
    public virtual ICollection<SystemTransaction>? SystemTransaction { get; set; }

    public virtual ICollection<ClinicService>? ClinicServices { get; set; }
    public virtual ICollection<UserClinic>? UserClinics { get; set; }

    public virtual ICollection<LivestreamRoom>? LivestreamRooms { get; set; }
    public virtual ICollection<ShiftConfig>? ShiftConfigs { get; set; }

    // public virtual ICollection<Category>? Categories { get; set; }
    public virtual ICollection<ClinicVoucher>? ClinicVouchers { get; set; }
    public virtual ICollection<UserConversation>? UserConversations { get; set; }
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/ClinicOnBoardingRequest.cs
================
using System.ComponentModel.DataAnnotations;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class ClinicOnBoardingRequest : AggregateRoot<Guid>, IAuditableEntity
{
    [MaxLength(50)] public int Status { get; set; } = 0;

    // 0 Pending 1 Approve 2 Reject 3 Banned
    [MaxLength(250)] public string? RejectReason { get; set; }
    public DateTimeOffset SendMailDate { get; set; }
    public required bool IsMain { get; set; }
    public Guid ClinicId { get; set; }
    public virtual Clinic? Clinic { get; set; }

    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/ClinicService.cs
================
namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class ClinicService : AggregateRoot<Guid>, IAuditableEntity
{
    public Guid ClinicId { get; set; }
    public virtual Clinic Clinics { get; set; }

    public Guid ServiceId { get; set; }
    public virtual Service Services { get; set; }

    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/ClinicTransaction.cs
================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class ClinicTransaction : AggregateRoot<Guid>, IAuditableEntity
{
    public Guid? OrderId { get; set; }
    public virtual Order? Order { get; set; }
    public Guid? ClinicId { get; set; }
    public virtual Clinic? Clinic { get; set; }
    public DateTimeOffset TransactionDate { get; set; } = DateTimeOffset.UtcNow;
    [Column(TypeName = "decimal(18,2)")] public decimal Amount { get; set; }
    [MaxLength(50)] public string? Status { get; set; }
    [MaxLength(50)] public string? PaymentMethod { get; set; }


    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/ClinicVoucher.cs
================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class ClinicVoucher : AggregateRoot<Guid>, IAuditableEntity
{
    public Guid ClinicId { get; set; }
    public virtual Clinic? Clinic { get; set; }
    public Guid ServiceId { get; set; }
    public virtual Service? Service { get; set; }
    [MaxLength(100)] public required string Name { get; set; }
    public double MaximumDiscountPercent { get; set; }
    [Column(TypeName = "decimal(18,2)")] public decimal MaximumDiscountAmount { get; set; }
    public int MaximumUsage { get; set; }
    public DateOnly? StartDate { get; set; }
    public DateOnly? EndDate { get; set; }
    [MaxLength(500)] public string? Description { get; set; }
    public bool IsActivated { get; set; } = false;
    public int? TotalUsage { get; set; }
    public virtual ICollection<Voucher>? Vouchers { get; set; } = [];

    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/Config.cs
================
namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class Config : AggregateRoot<Guid>, IAuditableEntity
{
    public required string Key { get; set; }
    public required string Value { get; set; }
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/Conversation.cs
================
using System.ComponentModel.DataAnnotations;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class Conversation : AggregateRoot<Guid>, IAuditableEntity
{
    [MaxLength(50)] public required string Type { get; set; }
    public virtual ICollection<Message>? Messages { get; set; }
    public virtual ICollection<UserConversation>? UserConversations { get; set; }

    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/CustomerSchedule.cs
================
using System.ComponentModel.DataAnnotations;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class CustomerSchedule : AggregateRoot<Guid>, IAuditableEntity
{
    public Guid CustomerId { get; set; }
    public virtual User? Customer { get; set; }
    public Guid ServiceId { get; set; }
    public virtual Service? Service { get; set; }
    public Guid DoctorId { get; set; }
    public virtual UserClinic? Doctor { get; set; }
    public TimeSpan? StartTime { get; set; }
    public TimeSpan? EndTime { get; set; }
    public DateOnly? Date { get; set; }
    public Guid? FeedbackId { get; set; }
    public virtual Feedback? Feedback { get; set; }
    [MaxLength(50)] public string? Status { get; set; }
    [MaxLength(2000)] public string? DoctorNote { get; set; }
    public Guid? ProcedurePriceTypeId { get; set; }
    public virtual ProcedurePriceTypes? ProcedurePriceType { get; set; }

    public Guid? ProcedureId { get; set; }
    public virtual Procedure? Procedure { get; set; }

    public Guid? OrderId { get; set; }
    public virtual Order? Order { get; set; }
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/DoctorCertificate.cs
================
using System.ComponentModel.DataAnnotations;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class DoctorCertificate : AggregateRoot<Guid>, IAuditableEntity
{
    public Guid DoctorId { get; set; }
    public virtual Staff? Doctor { get; set; }
    [MaxLength(250)] public required string CertificateUrl { get; set; }
    [MaxLength(100)] public required string CertificateName { get; set; }

    public Guid? ServiceId { get; set; }
    public virtual Service? Service { get; set; }
    public DateTimeOffset? ExpiryDate { get; set; }
    [MaxLength(100)] public string? Note { get; set; }

    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/DoctorService.cs
================
namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class DoctorService : AggregateRoot<Guid>, IAuditableEntity
{
    public Guid DoctorId { get; set; }
    public virtual Staff? Doctor { get; set; }
    public Guid ServiceId { get; set; }
    public virtual Service? Service { get; set; }
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/Feedback.cs
================
using System.ComponentModel.DataAnnotations;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class Feedback : AggregateRoot<Guid>, IAuditableEntity
{
    public Guid CustomerScheduleId { get; set; }
    [MaxLength(500)] public string? Content { get; set; }
    public int Rating { get; set; }
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/LiveStreamDetail.cs
================
namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class LiveStreamDetail : AggregateRoot<Guid>, IAuditableEntity
{
    public int JoinCount { get; set; }
    public int MessageCount { get; set; }
    public int ReactionCount { get; set; }
    public int TotalActivities { get; set; }
    public int TotalBooking { get; set; }
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}
/*
 * JoinCount = joinCount,
   MessageCount = messageCount,
   ReactionCount = reactionCount,
   TotalActivities = joinCount + messageCount + reactionCount,
   TotalBooking = completedBookingCount
 */

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/LivestreamRoom.cs
================
using System.ComponentModel.DataAnnotations;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class LivestreamRoom : AggregateRoot<Guid>, IAuditableEntity
{
    [MaxLength(100)] public required string Name { get; set; }
    public string? Description { get; set; }
    public string? Image { get; set; }
    public TimeOnly? StartDate { get; set; }
    public TimeOnly? EndDate { get; set; }
    [MaxLength(50)] public string? Status { get; set; }
    public DateOnly? Date { get; set; }
    [MaxLength(50)] public string? Type { get; set; }
    public int? Duration { get; set; }
    public int? TotalViewers { get; set; }
    public Guid? ClinicId { get; set; }
    public virtual Clinic Clinic { get; set; }
    public Guid? LiveStreamDetailId { get; set; }
    public virtual LiveStreamDetail? LiveStreamDetail { get; set; }
    public virtual ICollection<Promotion>? Promotions { get; set; }


    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/Message.cs
================
using System.ComponentModel.DataAnnotations;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class Message : AggregateRoot<Guid>, IAuditableEntity
{
    public Guid? ConversationId { get; set; }
    public virtual Conversation? Conversation { get; set; }

    public Guid SenderId { get; set; }
    //public virtual User? Sender { get; set; }

    public bool IsClinic { get; set; } = false;
    [MaxLength(200)] public required string Content { get; set; }
    public bool IsRead { get; set; } = false;
    public Guid? LivestreamRoomId { get; set; }
    public virtual LivestreamRoom? LivestreamRoom { get; set; }

    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/Order.cs
================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class Order : AggregateRoot<Guid>, IAuditableEntity
{
    public Guid CustomerId { get; set; }
    public virtual User? Customer { get; set; }
    [Column(TypeName = "decimal(18,2)")] public decimal? TotalAmount { get; set; }
    [Column(TypeName = "decimal(18,2)")] public decimal? Discount { get; set; }

    [Column(TypeName = "decimal(18,2)")] public required decimal DepositAmount { get; set; }
    [Column(TypeName = "decimal(18,2)")] public decimal? FinalAmount { get; set; }
    public DateOnly OrderDate { get; set; } = DateOnly.FromDateTime(DateTime.UtcNow);
    public Guid? ServiceId { get; set; }
    public virtual Service? Service { get; set; }
    public Guid? LivestreamRoomId { get; set; }
    public virtual LivestreamRoom? LivestreamRoom { get; set; }
    
    public Guid? OrderFeedbackId { get; set; }
    public virtual OrderFeedback? OrderFeedback { get; set; }
    
    [MaxLength(50)] public string? Status { get; set; }
    public virtual ICollection<OrderDetail>? OrderDetails { get; set; } = [];
    public virtual ICollection<CustomerSchedule>? CustomerSchedules { get; set; } = [];
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/OrderDetail.cs
================
using System.ComponentModel.DataAnnotations.Schema;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class OrderDetail : AggregateRoot<Guid>, IAuditableEntity
{
    public Guid OrderId { get; set; }
    public virtual Order? Order { get; set; }
    public Guid ProcedurePriceTypeId { get; set; }
    public virtual ProcedurePriceTypes? ProcedurePriceType { get; set; }

    [Column(TypeName = "decimal(18,2)")] public decimal Price { get; set; }

    // public Guid? FeedbackId { get; set; }
    public virtual Feedback? Feedback { get; set; }
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/OrderFeedback.cs
================
using System.ComponentModel.DataAnnotations;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class OrderFeedback : AggregateRoot<Guid>, IAuditableEntity
{
    public Guid OrderId { get; set; }
    [MaxLength(5000)] public string? Content { get; set; }
    public int Rating { get; set; }
    public virtual ICollection<OrderFeedbackMedia>? OrderFeedbackMedias { get; set; } = [];
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/OrderFeedbackMedia.cs
================
namespace BEAUTIFY_QUERY.DOMAIN.Entities;

public class OrderFeedbackMedia: AggregateRoot<Guid>, IAuditableEntity
{
    public Guid OrderId { get; set; }
    public virtual Order Order { get; set; } = default!;
    
    public string MediaUrl { get; set; } 
    
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/Procedure.cs
================
using System.ComponentModel.DataAnnotations;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class Procedure : AggregateRoot<Guid>, IAuditableEntity
{
    [MaxLength(100)] public required string Name { get; set; }
    public string Description { get; set; } = default!;
    public int StepIndex { get; set; }


    public Guid? ServiceId { get; set; }
    public virtual Service? Service { get; set; }
    public virtual ICollection<CustomerSchedule>? CustomerSchedules { get; set; } = [];
    public virtual ICollection<ProcedureMedia> ProcedureMedias { get; set; } = [];
    public virtual ICollection<ProcedurePriceTypes> ProcedurePriceTypes { get; set; } = [];

    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/ProcedureMedia.cs
================
namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class ProcedureMedia : AggregateRoot<Guid>, IAuditableEntity
{
    public string ImageUrl { get; set; } = default!;
    public int IndexNumber { get; set; }

    public Guid ProcedureId { get; set; } = default!;
    public virtual Procedure Procedure { get; set; } = default!;

    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/ProcedurePriceTypes.cs
================
using System.ComponentModel.DataAnnotations.Schema;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class ProcedurePriceTypes : AggregateRoot<Guid>, IAuditableEntity
{
    public string Name { get; set; } = default!;

    [Column(TypeName = "decimal(18,2)")] public decimal Price { get; set; }

    public required int Duration { get; set; }

    public required bool IsDefault { get; set; }
    public Guid ProcedureId { get; set; } = default!;
    public virtual Procedure Procedure { get; set; } = default!;

    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/Promotion.cs
================
using System.ComponentModel.DataAnnotations;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class Promotion : AggregateRoot<Guid>, IAuditableEntity
{
    [MaxLength(100)] public required string Name { get; set; }
    [MaxLength(250)] public string? ImageUrl { get; set; }
    public DateTimeOffset StartDate { get; set; }
    public DateTimeOffset EndDate { get; set; }
    [MaxLength(50)] public string? Status { get; set; }
    public double DiscountPercent { get; set; }
    public Guid? ServiceId { get; set; }
    public virtual Service? Service { get; set; }
    public bool IsActivated { get; set; } = false;
    public Guid? LivestreamRoomId { get; set; }
    public virtual LivestreamRoom? LivestreamRoom { get; set; }
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/Role.cs
================
using System.ComponentModel.DataAnnotations;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class Role : AggregateRoot<Guid>, IAuditableEntity
{
    [MaxLength(50)] public required string Name { get; set; }
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/Service.cs
================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class Service : AggregateRoot<Guid>, IAuditableEntity
{
    [MaxLength(50)] public required string Name { get; set; }
    [MaxLength(200)] public required string Description { get; set; }
    [Column(TypeName = "decimal(18,2)")] public decimal MaxPrice { get; set; }
    [Column(TypeName = "decimal(18,2)")] public decimal MinPrice { get; set; }
    public int NumberOfCustomersUsed { get; set; } = 0;

    public Guid? CategoryId { get; set; }
    public virtual Category? Category { get; set; }

    [Column(TypeName = "decimal(18,2)")] public decimal? DiscountPrice { get; set; }

    public virtual ICollection<ClinicService>? ClinicServices { get; set; }
    public virtual ICollection<ServiceMedia>? ServiceMedias { get; set; }
    public virtual ICollection<Promotion>? Promotions { get; set; }
    public virtual ICollection<Procedure>? Procedures { get; set; }
    public virtual ICollection<CustomerSchedule>? CustomerSchedules { get; set; }
    public virtual ICollection<OrderDetail>? OrderDetails { get; set; }
    public virtual ICollection<ClinicVoucher>? ClinicVouchers { get; set; }
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/ServiceMedia.cs
================
namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class ServiceMedia : AggregateRoot<Guid>, IAuditableEntity
{
    public string ImageUrl { get; set; } = default!;
    public int ServiceMediaType { get; set; } // 0 Product Slide, 1 Product Description
    public int IndexNumber { get; set; }

    public Guid ServiceId { get; set; } = default!;
    public virtual Service Service { get; set; } = default!;

    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/ShiftConfig.cs
================
namespace BEAUTIFY_QUERY.DOMAIN.Entities;

public class ShiftConfig: AggregateRoot<Guid>, IAuditableEntity
{
    public string Name { get; set; } = default!;
    public string? Note { get; set; }
    public TimeSpan StartTime { get; set; }
    public TimeSpan EndTime { get; set; }
    public Guid ClinicId { get; set; }
    public virtual Clinic Clinic { get; set; } = default!;
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/Staff.cs
================
using System.ComponentModel.DataAnnotations;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class Staff : AggregateRoot<Guid>, IAuditableEntity
{
    [RegularExpression(@"^([\w\.\-]+)@([\w\-]+)(\.[a-zA-Z]{2,})$", ErrorMessage = "Invalid Email Format")]
    [MaxLength(100)]
    [Required]
    public required string Email { get; init; }

    [MaxLength(50)] public required string FirstName { get; set; }
    [MaxLength(50)] public required string LastName { get; set; }
    public string FullName => $"{FirstName} {LastName}".Trim();
    [MaxLength(255)] public required string Password { get; set; }

    [MaxLength(50)] public required int Status { get; set; }

    // 0 Pending 1 Approve 2 Reject 3 Banned
    public DateOnly? DateOfBirth { get; set; }
    public Guid? RoleId { get; set; }
    public virtual Role? Role { get; set; }

    [MaxLength(14, ErrorMessage = "Phone Number must be 10 digits")]
    public string? PhoneNumber { get; set; }

    [MaxLength(250)] public string? ProfilePicture { get; set; }

    // address in detail
    [MaxLength(100)] public string? City { get; set; }
    [MaxLength(100)] public string? District { get; set; }
    [MaxLength(100)] public string? Ward { get; set; }
    [MaxLength(100)] public string? Address { get; set; }

    [MaxLength(250)] public string? FullAddress => $"{Address}, {Ward}, {District}, {City}".Trim(',', ' ', '\n');


    [MaxLength(250)] public string? RefreshToken { get; set; }


    public virtual ICollection<UserClinic>? UserClinics { get; set; }
    public virtual ICollection<DoctorCertificate>? DoctorCertificates { get; set; }
    public virtual ICollection<DoctorService>? DoctorServices { get; set; }

    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/SubscriptionPackage.cs
================
using System.ComponentModel.DataAnnotations.Schema;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class SubscriptionPackage : AggregateRoot<Guid>, IAuditableEntity
{
    public required string Name { get; set; }
    public required string Description { get; set; }
    [Column(TypeName = "decimal(18,2)")] public required decimal Price { get; set; }
    public required int Duration { get; set; }
    public bool IsActivated { get; set; }
    public int LimitBranch { get; set; }
    public int LimitLiveStream { get; set; }
    [Column(TypeName = "decimal(18,2)")] public decimal PriceMoreBranch { get; set; }
    [Column(TypeName = "decimal(18,2)")] public decimal PriceMoreLivestream { get; set; }
    public int EnhancedViewer { get; set; }
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/Survey.cs
================
namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class Survey : AggregateRoot<Guid>, IAuditableEntity
{
    public string? Name { get; set; }
    public string? Description { get; set; }

    public Guid? CategoryId { get; set; }
    public virtual Category? Category { get; set; }

    public virtual ICollection<SurveyQuestion>? SurveyQuestions { get; set; } = [];

    public virtual SurveyResponse? SurveyResponse { get; set; }
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/SurveyAnswer.cs
================
using System.ComponentModel.DataAnnotations;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class SurveyAnswer : AggregateRoot<Guid>, IAuditableEntity
{
    public Guid? SurveyQuestionId { get; set; }
    public virtual SurveyQuestion? SurveyQuestion { get; set; }
    public Guid? SurveyResponseId { get; set; }
    public virtual SurveyResponse? SurveyResponse { get; set; }
    [MaxLength(500)] public required string Answer { get; set; }

    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/SurveyQuestion.cs
================
using System.ComponentModel.DataAnnotations;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class SurveyQuestion : AggregateRoot<Guid>, IAuditableEntity
{
    public string? Question { get; set; }

    [MaxLength(30)] public string? QuestionType { get; set; }

    public Guid? SurveyId { get; set; }
    public virtual Survey? Survey { get; set; }

    public virtual ICollection<SurveyQuestionOption>? SurveyQuestionOptions { get; set; } = [];
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/SurveyQuestionOption.cs
================
using System.ComponentModel.DataAnnotations;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class SurveyQuestionOption : AggregateRoot<Guid>, IAuditableEntity
{
    public Guid SurveyQuestionId { get; set; }
    public virtual SurveyQuestion? SurveyQuestion { get; set; }

    [MaxLength(200)] public string? Option { get; set; }

    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/SurveyResponse.cs
================
namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class SurveyResponse : AggregateRoot<Guid>, IAuditableEntity
{
    public Guid SurveyId { get; set; }
    public virtual Survey? Survey { get; set; }
    public Guid? CustomerId { get; set; }
    public virtual User? Customer { get; set; }


    public virtual ICollection<SurveyAnswer> SurveyAnswers { get; set; } = [];


    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/SystemTransaction.cs
================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class SystemTransaction : AggregateRoot<Guid>, IAuditableEntity
{
    public Guid ClinicId { get; set; }
    public virtual Clinic? Clinic { get; set; }
    public Guid? SubscriptionPackageId { get; set; }
    public virtual SubscriptionPackage? SubscriptionPackage { get; set; }

    public int? AdditionBranches { get; set; }
    public int? AdditionLivestreams { get; set; }

    public Guid? OrderId { get; set; }
    public virtual Order? Order { get; set; }
    public DateTimeOffset TransactionDate { get; set; } = DateTimeOffset.UtcNow;
    [Column(TypeName = "decimal(18,2)")] public decimal Amount { get; set; }
    [MaxLength(50)] public string? PaymentMethod { get; set; }

    public int Status { get; set; } = 0;

    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/User.cs
================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class User : AggregateRoot<Guid>, IAuditableEntity
{
    [RegularExpression(@"^([\w\.\-]+)@([\w\-]+)(\.[a-zA-Z]{2,})$", ErrorMessage = "Invalid Email Format")]
    [MaxLength(100)]
    [Required]
    public required string Email { get; init; }

    [MaxLength(50)] public required string FirstName { get; set; }
    [MaxLength(50)] public required string LastName { get; set; }
    public string? FullName => $"{FirstName} {LastName}".Trim();
    [MaxLength(255)] public required string Password { get; set; }

    [MaxLength(50)] public required int Status { get; set; }

    // 0 Pending 1 Approve 2 Reject 3 Banned
    public DateOnly? DateOfBirth { get; set; }
    public Guid? RoleId { get; set; }
    public virtual Role? Role { get; set; }

    [MaxLength(14, ErrorMessage = "Phone Number must be 10 digits")]
    public string? PhoneNumber { get; set; }

    [Column(TypeName = "decimal(18,2)")] public decimal Balance { get; set; }
    [MaxLength(250)] public string? ProfilePicture { get; set; }

    // address in detail
    [MaxLength(100)] public string? City { get; set; }
    [MaxLength(100)] public string? District { get; set; }
    [MaxLength(100)] public string? Ward { get; set; }
    [MaxLength(100)] public string? Address { get; set; }

    [MaxLength(250)] public string? FullAddress => $"{Address}, {Ward}, {District}, {City}".Trim(',', ' ', '\n');


    [MaxLength(250)] public string? RefreshToken { get; set; }


    public virtual ICollection<UserConversation>? UserConversations { get; set; }
    public virtual ICollection<CustomerSchedule>? CustomerSchedules { get; set; }
    public virtual ICollection<Order>? Orders { get; set; }
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/UserClinic.cs
================
namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class UserClinic : AggregateRoot<Guid>, IAuditableEntity
{
    public Guid UserId { get; set; }
    public Guid ClinicId { get; set; }
    public virtual Clinic? Clinic { get; set; }
    public virtual Staff? User { get; set; }
    public virtual ICollection<CustomerSchedule>? CustomerSchedules { get; set; }
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/UserConversation.cs
================
namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class UserConversation : AggregateRoot<Guid>, IAuditableEntity
{
    public Guid UserId { get; set; }
    public virtual User User { get; set; } = null!;

    public Guid? ClinicId { get; set; }
    public virtual Clinic? Clinic { get; set; } = null!;

    public Guid ConversationId { get; set; }
    public virtual Conversation Conversation { get; set; } = null!;

    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/Voucher.cs
================
using System.ComponentModel.DataAnnotations;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class Voucher : AggregateRoot<Guid>, IAuditableEntity
{
    [MaxLength(6)] public required string Code { get; set; }

    public Guid? ClinicVoucherId { get; set; }
    public virtual ClinicVoucher? ClinicVoucher { get; set; }
    public Guid? OrderId { get; set; }
    public virtual Order? Order { get; set; }
    public bool IsUsed { get; set; } = false;
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/WalletTransaction.cs
================
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class WalletTransaction : AggregateRoot<Guid>, IAuditableEntity
{
    public Guid? UserId { get; set; }
    public virtual User? User { get; set; }

    public Guid? ClinicId { get; set; }
    public virtual Clinic? Clinic { get; set; }
    [Column(TypeName = "decimal(18,2)")] public decimal Amount { get; set; }


    // Transaction Type: 0 = Deposit, 1 = Withdrawal, 2 = Transfer
    [MaxLength(20)] public required string TransactionType { get; set; }

    // Status: 0 = Pending, 1 = Completed, 2 = Failed, 3 = Cancelled
    [MaxLength(20)] public required string Status { get; set; }

    public bool IsMakeBySystem { get; set; } = true;

    public string? NewestQrUrl { get; set; } = null;
    [MaxLength(255)] public string? Description { get; set; }

    public DateTime TransactionDate { get; set; } = DateTime.UtcNow;

    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Entities/WorkingSchedule.cs
================
namespace BEAUTIFY_QUERY.DOMAIN.Entities;
public class WorkingSchedule : AggregateRoot<Guid>, IAuditableEntity
{
    public Guid? ClinicId { get; set; }
    public virtual Clinic? Clinic { get; set; }
    public Guid? DoctorId { get; set; }
    public virtual Staff? Doctor { get; set; }


    public Guid? CustomerScheduleId { get; set; }
    public virtual CustomerSchedule? CustomerSchedule { get; set; }
    public DateOnly Date { get; set; }
    public TimeSpan StartTime { get; set; }
    public TimeSpan EndTime { get; set; }
    public Guid? ShiftGroupId { get; set; } // Added to group schedules in the same shift

    public virtual ShiftConfig? ShiftGroup { get; set; }
    public int? ShiftCapacity { get; set; } // Added to track how many doctors can work in this shift
    public DateTimeOffset CreatedOnUtc { get; set; }
    public DateTimeOffset? ModifiedOnUtc { get; set; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Exceptions/BadRequestException.cs
================
namespace BEAUTIFY_QUERY.DOMAIN.Exceptions;
public abstract class BadRequestException : DomainException
{
    protected BadRequestException(string message)
        : base("Bad Request", message)
    {
    }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Exceptions/DoctorCertificateException.cs
================
namespace BEAUTIFY_QUERY.DOMAIN.Exceptions;
public static class DoctorCertificateException
{
    public class DoctorCertificateNotFoundException : NotFoundException
    {
        public DoctorCertificateNotFoundException(Guid doctorCertificateId)
            : base($"The doctor certificate with the id {doctorCertificateId} was not found.")
        {
        }
    }

    public class DoctorCertificateFieldException : NotFoundException
    {
        public DoctorCertificateFieldException(string doctorCertificateField)
            : base($"The doctor certificate with the field {doctorCertificateField} is not correct.")
        {
        }
    }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Exceptions/DomainException.cs
================
namespace BEAUTIFY_QUERY.DOMAIN.Exceptions;
public abstract class DomainException : Exception
{
    protected DomainException(string title, string message)
        : base(message)
    {
        Title = title;
    }

    public string Title { get; }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Exceptions/IdentityException.cs
================
namespace BEAUTIFY_QUERY.DOMAIN.Exceptions;
public static class IdentityException
{
    public class TokenException : DomainException
    {
        public TokenException(string message)
            : base("Token Exception", message)
        {
        }
    }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Exceptions/NotFoundException.cs
================
namespace BEAUTIFY_QUERY.DOMAIN.Exceptions;
public abstract class NotFoundException : DomainException
{
    protected NotFoundException(string message)
        : base("Not Found", message)
    {
    }
}

================
File: BEAUTIFY_QUERY.DOMAIN/Exceptions/ProductException.cs
================
namespace BEAUTIFY_QUERY.DOMAIN.Exceptions;
public static class ProductException
{
    public class ProductNotFoundException : NotFoundException
    {
        public ProductNotFoundException(Guid productId)
            : base($"The product with the id {productId} was not found.")
        {
        }
    }

    public class ProductFieldException : NotFoundException
    {
        public ProductFieldException(string productField)
            : base($"The product with the field {productField} is not correct.")
        {
        }
    }
}

================
File: BEAUTIFY_QUERY.DOMAIN/GlobalUsings.cs
================
global using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Aggregates;
global using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Entities;

================
File: BEAUTIFY_QUERY.INFRASTRUCTURE/AssemblyReference.cs
================
using System.Reflection;

namespace BEAUTIFY_QUERY.INFRASTRUCTURE;
public static class AssemblyReference
{
    public static readonly Assembly Assembly = typeof(AssemblyReference).Assembly;
}

================
File: BEAUTIFY_QUERY.INFRASTRUCTURE/BEAUTIFY_QUERY.INFRASTRUCTURE.csproj
================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="BEAUTIFY_PACKAGES.SHARE" Version="1.12.6" />
        <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="8.0.4" />
    </ItemGroup>

    <ItemGroup>
      <ProjectReference Include="..\BEAUTIFY_QUERY.APPLICATION\BEAUTIFY_QUERY.APPLICATION.csproj" />
    </ItemGroup>

    <ItemGroup>
        <PackageVersion Update="BEAUTIFY_PACKAGES.SHARE" Version="1.6.0" />
    </ItemGroup>

</Project>

================
File: BEAUTIFY_QUERY.INFRASTRUCTURE/Consumer/MessageBus/Consumers/Events/ClinicConsumer.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Services.Clinic;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Repositories;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Documents;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.INFRASTRUCTURE.Consumer.Abstractions.Messages;
using MediatR;

namespace BEAUTIFY_QUERY.INFRASTRUCTURE.Consumer.MessageBus.Consumers.Events;

public static class ClinicConsumer
{
    public class ClinicBranchActivatedActionConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.ClinicBranchActivatedAction>(sender, repository);
    
    
    public class ClinicDeletedConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.ClinicDeleted>(sender, repository);
    
    public class ClinicUpdatedConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.ClinicUpdated>(sender, repository);
}

================
File: BEAUTIFY_QUERY.INFRASTRUCTURE/Consumer/MessageBus/Consumers/Events/ClinicServiceConsumer.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Services.ClinicServices;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Repositories;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Documents;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.INFRASTRUCTURE.Consumer.Abstractions.Messages;
using MediatR;

namespace BEAUTIFY_QUERY.INFRASTRUCTURE.Consumer.MessageBus.Consumers.Events;
public static class ClinicServiceConsumer
{
    public class ClinicServiceCreatedConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.ClinicServiceCreated>(sender, repository);

    public class ClinicServiceUpdatedConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.ClinicServiceUpdated>(sender, repository);

    public class ClinicServiceDeletedConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.ClinicServiceDeleted>(sender, repository);
}

================
File: BEAUTIFY_QUERY.INFRASTRUCTURE/Consumer/MessageBus/Consumers/Events/CustomerScheduleConsumer.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Services.CustomerSchedules;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Repositories;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Documents;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.INFRASTRUCTURE.Consumer.Abstractions.Messages;
using MediatR;

namespace BEAUTIFY_QUERY.INFRASTRUCTURE.Consumer.MessageBus.Consumers.Events;
public class CustomerScheduleConsumer
{
    public class CustomerScheduleCreatedEvent(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.CustomerScheduleCreated>(sender, repository);

    public class CustomerScheduleDeletedEvent(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.CustomerScheduleDeleted>(sender, repository);

    public class CustomerScheduleUpdateAfterPaymentCompletedEvent(
        ISender sender,
        IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.CustomerScheduleUpdateAfterPaymentCompleted>(sender, repository);

    public class CustomerScheduleUpdatedDoctorNoteEvent(
        ISender sender,
        IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.CustomerScheduleUpdatedDoctorNote>(sender, repository);

    public class CustomerScheduleUpdateDateAndTimeEvent(
        ISender sender,
        IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.CustomerScheduleUpdateDateAndTimeAndStatus>(sender, repository);

    public class ChangeDoctorMultipleEvent(
        ISender sender,
        IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.CustomerScheduleDoctorChangedMultiple>(sender, repository);
}

================
File: BEAUTIFY_QUERY.INFRASTRUCTURE/Consumer/MessageBus/Consumers/Events/DoctorServicesConsumer.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Services.DoctorServices;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Repositories;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Documents;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.INFRASTRUCTURE.Consumer.Abstractions.Messages;
using MediatR;

namespace BEAUTIFY_QUERY.INFRASTRUCTURE.Consumer.MessageBus.Consumers.Events;
public class DoctorServicesConsumer
{
    public class DoctorServiceCreatedConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.DoctorServiceCreated>(sender, repository);

    public class DoctorServiceDeletedConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.DoctorServiceDeleted>(sender, repository);
}

================
File: BEAUTIFY_QUERY.INFRASTRUCTURE/Consumer/MessageBus/Consumers/Events/FeedbackConsumer.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Services.Feedback;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Repositories;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Documents;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.INFRASTRUCTURE.Consumer.Abstractions.Messages;
using MediatR;

namespace BEAUTIFY_QUERY.INFRASTRUCTURE.Consumer.MessageBus.Consumers.Events;
public class FeedbackConsumer
{
    public class CreateFeedbackConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.CreateFeedback>(sender, repository);

    public class UpdateFeedbackConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.UpdateFeedback>(sender, repository);

    public class ViewActionFeedbackConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.ViewActionFeedback>(sender, repository);
}

================
File: BEAUTIFY_QUERY.INFRASTRUCTURE/Consumer/MessageBus/Consumers/Events/ServiceProcedureConsumer.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Services.Procedures;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Repositories;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Documents;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.INFRASTRUCTURE.Consumer.Abstractions.Messages;
using MediatR;

namespace BEAUTIFY_QUERY.INFRASTRUCTURE.Consumer.MessageBus.Consumers.Events;
public class ServiceProcedureConsumer
{
    public class ProcedureCreatedConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.ProcedureCreated>(sender, repository);

    public class ProcedureUpdatedConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.ProcedureUpdate>(sender, repository);

    public class ProcedureDeletedConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.ProcedureDelete>(sender, repository);
}

================
File: BEAUTIFY_QUERY.INFRASTRUCTURE/Consumer/MessageBus/Consumers/Events/ServicePromotionConsumer.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Services.ServicePromotion;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Repositories;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Documents;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.INFRASTRUCTURE.Consumer.Abstractions.Messages;
using MediatR;

namespace BEAUTIFY_QUERY.INFRASTRUCTURE.Consumer.MessageBus.Consumers.Events;
public class ServicePromotionConsumer
{
    public class ServicePromotionCreatedConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.ServicePromotionCreated>(sender, repository);

    public class ServicePromotionUpdatedConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.ServicePromotionUpdated>(sender, repository);

    public class ServicePromotionDeletedConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.ServicePromotionDeleted>(sender, repository);
}

================
File: BEAUTIFY_QUERY.INFRASTRUCTURE/Consumer/MessageBus/Consumers/Events/UserClinicConsumer.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Services.Clinic;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Repositories;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Documents;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.INFRASTRUCTURE.Consumer.Abstractions.Messages;
using MediatR;

namespace BEAUTIFY_QUERY.INFRASTRUCTURE.Consumer.MessageBus.Consumers.Events;
public class UserClinicConsumer
{
    public class DoctorFromClinicDeletedConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.DoctorFromClinicDeleted>(sender, repository);
}

================
File: BEAUTIFY_QUERY.INFRASTRUCTURE/Consumer/MessageBus/Consumers/Events/WorkingScheduleConsumer.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Services.WorkingSchedules;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Repositories;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Documents;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.INFRASTRUCTURE.Consumer.Abstractions.Messages;
using MediatR;

namespace BEAUTIFY_QUERY.INFRASTRUCTURE.Consumer.MessageBus.Consumers.Events;
public static class WorkingScheduleConsumer
{
    public class WorkingScheduleCreatedConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.WorkingScheduleCreated>(sender, repository);

    public class WorkingScheduleDeletedConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.WorkingScheduleDeleted>(sender, repository);

    public class WorkingScheduleUpdatedConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.WorkingScheduleUpdated>(sender, repository);

    public class ClinicEmptyScheduleCreatedConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.ClinicEmptyScheduleCreated>(sender, repository);

    public class ClinicScheduleCapacityChangedConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.ClinicScheduleCapacityChanged>(sender, repository);

    public class DoctorScheduleRegisteredConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.DoctorScheduleRegistered>(sender, repository);
}

================
File: BEAUTIFY_QUERY.INFRASTRUCTURE/Consumer/MessageBus/Consumers/PostgreConsumer/PostgreMigrateConsumer.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Services.CommandConverts;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Repositories;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Documents;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.INFRASTRUCTURE.Consumer.Abstractions.Messages;
using MediatR;

namespace BEAUTIFY_QUERY.INFRASTRUCTURE.Consumer.MessageBus.Consumers.PostgreConsumer;
public static class PostgreConsumer
{
    // public class SubscriptionCreatedConsumer(ISender sender, IMongoRepository<EventProjection> repository)
    //     : Consumer<DomainEvents.SubscriptionCreated>(sender, repository);

    public class PostgreMigrateConsumer(ISender sender, IMongoRepository<EventProjection> repository)
        : Consumer<DomainEvents.PostgreMigrate>(sender, repository);
}

================
File: BEAUTIFY_QUERY.INFRASTRUCTURE/DependencyInjection/Extensions/ServiceCollectionExtensions.cs
================
using System.Reflection;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.APPLICATION.Abstractions;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.JsonConverters;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.INFRASTRUCTURE.Caching;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.INFRASTRUCTURE.DependencyInjection.Extensions;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.INFRASTRUCTURE.DependencyInjection.Options;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.INFRASTRUCTURE.PipeObservers;
using MassTransit;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json;

namespace BEAUTIFY_QUERY.INFRASTRUCTURE.DependencyInjection.Extensions;
public static class ServiceCollectionExtensions
{
    public static void AddServicesInfrastructure(this IServiceCollection services)
    {
        services.AddTransient<ICacheService, CacheService>();
    }

    // Configure Redis
    public static void AddRedisInfrastructure(this IServiceCollection services, IConfiguration configuration)
    {
        services.AddStackExchangeRedisCache(redisOptions =>
        {
            var connectionString = configuration.GetConnectionString("Redis");
            redisOptions.Configuration = connectionString;
        });
    }

    // Configure for masstransit with rabbitMQ
    public static IServiceCollection AddMasstransitRabbitMqInfrastructure(this IServiceCollection services,
        IConfiguration configuration)
    {
        var masstransitConfiguration = new MasstransitConfiguration();
        configuration.GetSection(nameof(MasstransitConfiguration)).Bind(masstransitConfiguration);

        var messageBusOption = new MessageBusOptions();
        configuration.GetSection(nameof(MessageBusOptions)).Bind(messageBusOption);

        services.AddMassTransit(cfg =>
        {
            // ===================== Setup for Consumer =====================
            cfg.AddConsumers(Assembly
                .GetExecutingAssembly()); // Add all of consumers to masstransit instead above command

            // ?? => Configure endpoint formatter. Not configure for producer Root Exchange
            cfg.SetKebabCaseEndpointNameFormatter(); // ??

            cfg.UsingRabbitMq((context, bus) =>
            {
                bus.Host(masstransitConfiguration.Host, masstransitConfiguration.Port, masstransitConfiguration.VHost,
                    h =>
                    {
                        h.Username(masstransitConfiguration.UserName);
                        h.Password(masstransitConfiguration.Password);
                    });

                bus.UseMessageRetry(retry
                    => retry.Incremental(
                        messageBusOption.RetryLimit,
                        messageBusOption.InitialInterval,
                        messageBusOption.IntervalIncrement));

                bus.UseNewtonsoftJsonSerializer();

                bus.ConfigureNewtonsoftJsonSerializer(settings =>
                {
                    settings.Converters.Add(new TypeNameHandlingConverter(TypeNameHandling.Objects));
                    settings.Converters.Add(new DateOnlyJsonConverter());
                    settings.Converters.Add(new ExpirationDateOnlyJsonConverter());
                    return settings;
                });

                bus.ConfigureNewtonsoftJsonDeserializer(settings =>
                {
                    settings.Converters.Add(new TypeNameHandlingConverter(TypeNameHandling.Objects));
                    settings.Converters.Add(new DateOnlyJsonConverter());
                    settings.Converters.Add(new ExpirationDateOnlyJsonConverter());
                    return settings;
                });

                bus.ConnectReceiveObserver(new LoggingReceiveObserver());
                bus.ConnectConsumeObserver(new LoggingConsumeObserver());
                bus.ConnectPublishObserver(new LoggingPublishObserver());
                bus.ConnectSendObserver(new LoggingSendObserver());

                // Rename for Root Exchange and setup for consumer also
                bus.MessageTopology.SetEntityNameFormatter(new KebabCaseEntityNameFormatter());

                // ===================== Setup for Consumer =====================

                // Important to create Exchange and Queue
                bus.ConfigureEndpoints(context);
            });
        });

        return services;
    }

    public static void AddMediatRInfrastructure(this IServiceCollection services)
    {
        services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(AssemblyReference.Assembly));
        // services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(Application.AssemblyReference.Assembly));
    }
}

================
File: BEAUTIFY_QUERY.PERSISTENCE/ApplicationDbContext.cs
================
using System.Reflection;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Entities;
using BEAUTIFY_QUERY.DOMAIN.Entities;
using Microsoft.EntityFrameworkCore;

namespace BEAUTIFY_QUERY.PERSISTENCE;
public class ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) : DbContext(options)
{
    public virtual DbSet<Survey> Surveys { get; set; }
    public virtual DbSet<SurveyQuestion> SurveyQuestions { get; set; }
    public virtual DbSet<SurveyAnswer> SurveyAnswers { get; set; }
    public virtual DbSet<SurveyResponse> SurveyResponses { get; set; }
    public virtual DbSet<ClinicTransaction> ClinicTransactions { get; set; }
    public virtual DbSet<WalletTransaction> WalletTransaction { get; set; }
    public virtual DbSet<Procedure> Procedures { get; set; }
    public virtual DbSet<ProcedurePriceTypes> ProcedurePriceTypes { get; set; }

    private static void SetSoftDeleteFilter<T>(ModelBuilder modelBuilder) where T : Entity<T>
    {
        modelBuilder.Entity<T>().HasQueryFilter(e => !e.IsDeleted);
    }

    protected override void OnModelCreating(ModelBuilder builder)
    {
        builder.Entity<Category>().HasQueryFilter(x => !x.IsDeleted);
        builder.Entity<Order>().HasQueryFilter(x => !x.IsDeleted);
        builder.ApplyConfigurationsFromAssembly(AssemblyReference.Assembly);
        
        builder.Entity<CustomerSchedule>()
            .HasOne(cs => cs.Customer)
            .WithMany(u => u.CustomerSchedules)
            .HasForeignKey(cs => cs.CustomerId)
            .OnDelete(DeleteBehavior.NoAction); // Prevent cascade delete
        builder.Entity<User>()
            .HasIndex(x => x.Email)
            .IsUnique()
            .HasAnnotation("SqlServer:CaseSensitive", true);
        builder.Entity<User>()
            .HasIndex(x => x.PhoneNumber)
            .IsUnique();

        builder.Entity<SubscriptionPackage>()
            .HasQueryFilter(x => !x.IsDeleted);
        builder.Entity<DoctorCertificate>()
            .HasQueryFilter(x => !x.IsDeleted);
        builder.Entity<WalletTransaction>()
            .HasQueryFilter(x => !x.IsDeleted);

        foreach (var entityType in builder.Model.GetEntityTypes())
        {
            if (entityType.ClrType.BaseType is not { IsGenericType: true } ||
                entityType.ClrType.BaseType.GetGenericTypeDefinition() != typeof(Entity<>)) continue;
            var method = typeof(ApplicationDbContext)
                .GetMethod(nameof(SetSoftDeleteFilter), BindingFlags.NonPublic | BindingFlags.Static)
                ?.MakeGenericMethod(entityType.ClrType);

            method?.Invoke(null, [builder]);
        }

        builder.Entity<CustomerSchedule>().HasQueryFilter(x => !x.IsDeleted);
        
        builder.Entity<Order>()
            .HasOne(lr => lr.OrderFeedback)
            .WithOne() // Assuming one-to-one relationship, adjust if it's one-to-many
            .HasForeignKey<Order>(lr => lr.OrderFeedbackId)
            .OnDelete(DeleteBehavior.Restrict); // Adjust delete behavior as needed
        
        builder.Entity<CustomerSchedule>()
            .HasOne(lr => lr.Feedback)
            .WithOne() // Assuming one-to-one relationship, adjust if it's one-to-many
            .HasForeignKey<CustomerSchedule>(lr => lr.FeedbackId)
            .OnDelete(DeleteBehavior.Restrict); // Adjust delete behavior as needed
        
        // builder.Entity<Procedure>()
        //     .HasMany(lr => lr.ProcedurePriceTypes)
        //     .WithOne() // Assuming one-to-one relationship, adjust if it's one-to-many
        //     .HasForeignKey(lr => lr.ProcedureId)
        //     .OnDelete(DeleteBehavior.Restrict); // Adjust delete behavior as needed
        
        builder.Entity<ProcedurePriceTypes>()
            .HasOne(p => p.Procedure)
            .WithMany(p => p.ProcedurePriceTypes)
            .HasForeignKey(p => p.ProcedureId)
            .OnDelete(DeleteBehavior.Cascade);
    }
}

================
File: BEAUTIFY_QUERY.PERSISTENCE/AssemblyReference.cs
================
using System.Reflection;

namespace BEAUTIFY_QUERY.PERSISTENCE;
public static class AssemblyReference
{
    public static readonly Assembly Assembly = typeof(AssemblyReference).Assembly;
}

================
File: BEAUTIFY_QUERY.PERSISTENCE/BEAUTIFY_QUERY.PERSISTENCE.csproj
================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="BEAUTIFY_PACKAGES.SHARE" Version="1.12.6"/>
        <PackageReference Include="Microsoft.EntityFrameworkCore.Proxies" Version="8.0.7"/>
        <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="8.0.7"/>
        <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="8.0.4"/>
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\BEAUTIFY_QUERY.DOMAIN\BEAUTIFY_QUERY.DOMAIN.csproj"/>
    </ItemGroup>

    <ItemGroup>
        <PackageVersion Update="BEAUTIFY_PACKAGES.SHARE" Version="1.6.0"/>
    </ItemGroup>

</Project>

================
File: BEAUTIFY_QUERY.PERSISTENCE/DependencyInjection/Extensions/ServiceCollectionExtensions.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Repositories;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.PERSISTENCE.DependencyInjection.Options;
using BEAUTIFY_QUERY.PERSISTENCE.Repositories;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;

//using Npgsql.EntityFrameworkCore.PostgreSQL;

namespace BEAUTIFY_QUERY.PERSISTENCE.DependencyInjection.Extensions;
public static class ServiceCollectionExtensions
{
    public static void AddSqlServerPersistence(this IServiceCollection services)
    {
        services.AddDbContextPool<DbContext, ApplicationDbContext>((provider, builder) =>
        {
            var configuration = provider.GetRequiredService<IConfiguration>();
            var options = provider.GetRequiredService<IOptionsMonitor<SqlServerRetryOptions>>();

            #region ============== SQL-SERVER-STRATEGY-1 ==============

            builder
                .EnableDetailedErrors()
                .EnableSensitiveDataLogging()
                .UseLazyLoadingProxies() // => If UseLazyLoadingProxies, all of the navigation fields should be VIRTUAL
                .UseSqlServer(
                    configuration.GetConnectionString("ConnectionStrings"),
                    optionsBuilder
                        => optionsBuilder.ExecutionStrategy(dependencies => new SqlServerRetryingExecutionStrategy(
                                dependencies,
                                options.CurrentValue.MaxRetryCount,
                                options.CurrentValue.MaxRetryDelay,
                                options.CurrentValue.ErrorNumbersToAdd))
                            .MigrationsAssembly(typeof(ApplicationDbContext).Assembly.GetName().Name));

            #endregion ============== SQL-SERVER-STRATEGY-1 ==============

            #region ============== SQL-SERVER-STRATEGY-2 ==============

            //builder
            //.EnableDetailedErrors(true)
            //.EnableSensitiveDataLogging(true)
            //.UseLazyLoadingProxies(true) // => If UseLazyLoadingProxies, all of the navigation fields should be VIRTUAL
            //.UseSqlServer(
            //    connectionString: configuration.GetConnectionString("ConnectionStrings"),
            //        sqlServerOptionsAction: optionsBuilder
            //            => optionsBuilder
            //            .MigrationsAssembly(typeof(ApplicationDbContext).Assembly.GetName().Name));

            #endregion ============== SQL-SERVER-STRATEGY-2 ==============
        });
    }

    // public static void AddPostgreSqlPersistence(this IServiceCollection services)
    // {
    //     services.AddDbContextPool<DbContext, ApplicationDbContext>((provider, builder) =>
    //     {
    //         var configuration = provider.GetRequiredService<IConfiguration>();
    //         var options = provider.GetRequiredService<IOptionsMonitor<PostgreSqlRetryOptions>>();
    //
    //         #region ============== POSTGRESQL-STRATEGY-1 ==============
    //
    //         builder
    //             .EnableDetailedErrors()
    //             .EnableSensitiveDataLogging()
    //             .UseLazyLoadingProxies() // => If UseLazyLoadingProxies, all of the navigation fields should be VIRTUAL
    //             .UseNpgsql(
    //                 configuration.GetConnectionString("PostgreSqlConnection"),
    //                 npgsqlOptionsAction: optionsBuilder =>
    //                     optionsBuilder.ExecutionStrategy(dependencies =>
    //                         new NpgsqlRetryingExecutionStrategy(
    //                             dependencies,
    //                             options.CurrentValue.MaxRetryCount,
    //                             options.CurrentValue.MaxRetryDelay,
    //                             []))
    //                     .MigrationsAssembly(typeof(ApplicationDbContext).Assembly.GetName().Name)
    //                     .UseQuerySplittingBehavior(QuerySplittingBehavior.SplitQuery)); // Optional: Optimize performance
    //
    //         #endregion ============== POSTGRESQL-STRATEGY-1 ==============
    //
    //         #region ============== POSTGRESQL-STRATEGY-2 ==============
    //
    //         //builder
    //         //.EnableDetailedErrors(true)
    //         //.EnableSensitiveDataLogging(true)
    //         //.UseLazyLoadingProxies(true) // => If UseLazyLoadingProxies, all of the navigation fields should be VIRTUAL
    //         //.UseNpgsql(
    //         //    configuration.GetConnectionString("PostgreSqlConnection"),
    //         //    npgsqlOptionsAction: optionsBuilder
    //         //        => optionsBuilder
    //         //        .MigrationsAssembly(typeof(ApplicationDbContext).Assembly.GetName().Name));
    //
    //         #endregion ============== POSTGRESQL-STRATEGY-2 ==============
    //     });
    // }

    public static void ConfigureServicesInfrastructure(this IServiceCollection services, IConfiguration configuration)
    {
        services.Configure<MongoDbSettings>(configuration.GetSection(nameof(MongoDbSettings)));

        services.AddSingleton<IMongoDbSettings>(serviceProvider =>
            serviceProvider.GetRequiredService<IOptions<MongoDbSettings>>().Value);

        services.AddScoped(typeof(IMongoRepository<>), typeof(MongoRepository<>));
    }

    public static void AddRepositoryPersistence(this IServiceCollection services)
    {
        services.AddTransient(typeof(IRepositoryBase<,>), typeof(RepositoryBase<,>));
    }

    public static OptionsBuilder<SqlServerRetryOptions> ConfigureSqlServerRetryOptionsPersistence(
        this IServiceCollection services, IConfigurationSection section)
    {
        return services
            .AddOptions<SqlServerRetryOptions>()
            .Bind(section)
            .ValidateDataAnnotations()
            .ValidateOnStart();
    }

    // public static OptionsBuilder<PostgreSqlRetryOptions> ConfigurePostgreSqlRetryOptionsPersistence(
    //     this IServiceCollection services, IConfigurationSection section)
    // {
    //     return services
    //         .AddOptions<PostgreSqlRetryOptions>()
    //         .Bind(section)
    //         .ValidateDataAnnotations()
    //         .ValidateOnStart();
    // }
}

================
File: BEAUTIFY_QUERY.PERSISTENCE/Repositories/MongoRepository.cs
================
using System.Linq.Expressions;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Attributes;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Entities;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Repositories;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.PERSISTENCE.DependencyInjection.Options;
using MongoDB.Bson;
using MongoDB.Driver;
using MongoDB.Driver.Linq;

namespace BEAUTIFY_QUERY.PERSISTENCE.Repositories;
public class MongoRepository<TDocument> : IMongoRepository<TDocument>
    where TDocument : IDocument
{
    private readonly IMongoCollection<TDocument> _collection;

    public MongoRepository(IMongoDbSettings settings)
    {
        var database = new MongoClient(settings.ConnectionString).GetDatabase(settings.DatabaseName);
        _collection = database.GetCollection<TDocument>(GetCollectionName(typeof(TDocument)));
    }

    public virtual IMongoQueryable<TDocument> AsQueryable(Expression<Func<TDocument, bool>>? filterExpression = null)
    {
        return filterExpression is not null
            ? _collection.AsQueryable().Where(filterExpression)
            : _collection.AsQueryable();
    }

    public virtual async Task<UpdateResult> UpdateOneAsync(
        FilterDefinition<TDocument> filter,
        UpdateDefinition<TDocument> update,
        UpdateOptions options = null,
        CancellationToken cancellationToken = default)
    {
        // Perform the update operation
        return await _collection.UpdateOneAsync(filter, update, options, cancellationToken);
    }

    public virtual IEnumerable<TDocument> FilterBy(
        Expression<Func<TDocument, bool>> filterExpression)
    {
        return _collection.Find(filterExpression).ToEnumerable();
    }

    public virtual IEnumerable<TProjected> FilterBy<TProjected>(
        Expression<Func<TDocument, bool>> filterExpression,
        Expression<Func<TDocument, TProjected>> projectionExpression)
    {
        return _collection.Find(filterExpression).Project(projectionExpression).ToEnumerable();
    }

    public virtual TDocument FindOne(Expression<Func<TDocument, bool>> filterExpression)
    {
        return _collection.Find(filterExpression).FirstOrDefault();
    }

    public virtual Task<TDocument?> FindOneAsync(Expression<Func<TDocument, bool>> filterExpression)
    {
        return Task.Run(() => _collection.Find(filterExpression).FirstOrDefaultAsync());
    }

    public virtual TDocument FindById(string id)
    {
        var objectId = new ObjectId(id);
        var filter = Builders<TDocument>.Filter.Eq(doc => doc.Id, objectId);
        return _collection.Find(filter).SingleOrDefault();
    }

    public virtual Task<TDocument> FindByIdAsync(string id)
    {
        return Task.Run(() =>
        {
            var objectId = new ObjectId(id);
            var filter = Builders<TDocument>.Filter.Eq(doc => doc.Id, objectId);
            return _collection.Find(filter).SingleOrDefaultAsync();
        });
    }


    public virtual void InsertOne(TDocument document)
    {
        _collection.InsertOne(document);
    }

    public virtual Task InsertOneAsync(TDocument document)
    {
        return Task.Run(() => _collection.InsertOneAsync(document));
    }

    public void InsertMany(ICollection<TDocument> documents)
    {
        _collection.InsertMany(documents);
    }


    public virtual async Task InsertManyAsync(ICollection<TDocument> documents)
    {
        await _collection.InsertManyAsync(documents);
    }

    public void ReplaceOne(TDocument document)
    {
        var filter = Builders<TDocument>.Filter.Eq(doc => doc.Id, document.Id);
        _collection.FindOneAndReplace(filter, document);
    }

    public virtual async Task ReplaceOneAsync(TDocument document)
    {
        var filter = Builders<TDocument>.Filter.Eq(doc => doc.Id, document.Id);
        await _collection.FindOneAndReplaceAsync(filter, document);
    }

    public void DeleteOne(Expression<Func<TDocument, bool>> filterExpression)
    {
        _collection.FindOneAndDelete(filterExpression);
    }

    public Task DeleteOneAsync(Expression<Func<TDocument, bool>> filterExpression)
    {
        return Task.Run(() => _collection.FindOneAndDeleteAsync(filterExpression));
    }

    public void DeleteById(string id)
    {
        var objectId = new ObjectId(id);
        var filter = Builders<TDocument>.Filter.Eq(doc => doc.Id, objectId);
        _collection.FindOneAndDelete(filter);
    }

    public Task DeleteByIdAsync(string id)
    {
        return Task.Run(() =>
        {
            var objectId = new ObjectId(id);
            var filter = Builders<TDocument>.Filter.Eq(doc => doc.Id, objectId);
            _collection.FindOneAndDeleteAsync(filter);
        });
    }

    public void DeleteMany(Expression<Func<TDocument, bool>> filterExpression)
    {
        _collection.DeleteMany(filterExpression);
    }

    public Task DeleteManyAsync(Expression<Func<TDocument, bool>> filterExpression)
    {
        return Task.Run(() => _collection.DeleteManyAsync(filterExpression));
    }

    private static string GetCollectionName(Type documentType)
    {
        return ((BsonCollectionAttribute)documentType.GetCustomAttributes(
                typeof(BsonCollectionAttribute), true)
            .FirstOrDefault())?.CollectionName;
    }
}

================
File: BEAUTIFY_QUERY.PERSISTENCE/Repositories/RepositoryBase.cs
================
using System.Linq.Expressions;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Entities;
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Abstractions.Repositories;
using Microsoft.EntityFrameworkCore;

namespace BEAUTIFY_QUERY.PERSISTENCE.Repositories;
public class RepositoryBase<TEntity, TKey> : IRepositoryBase<TEntity, TKey>, IDisposable
    where TEntity : Entity<TKey>
{
    private readonly ApplicationDbContext _dbContext;

    public RepositoryBase(ApplicationDbContext dbContext)
    {
        _dbContext = dbContext;
    }

    public void Dispose()
    {
        _dbContext?.Dispose();
    }

    public IQueryable<TEntity> FindAll(Expression<Func<TEntity, bool>>? predicate = null,
        params Expression<Func<TEntity, object>>[] includeProperties)
    {
        var items = _dbContext.Set<TEntity>().AsNoTracking(); // Importance Always include AsNoTracking for Query Side
        if (includeProperties != null)
            foreach (var includeProperty in includeProperties)
                items = items.Include(includeProperty);

        if (predicate is not null)
            items = items.Where(predicate);

        return items;
    }

    public async Task<TEntity> FindByIdAsync(TKey id, CancellationToken cancellationToken = default,
        params Expression<Func<TEntity, object>>[] includeProperties)
    {
        return await FindAll(null, includeProperties)
            .AsTracking()
            .SingleOrDefaultAsync(x => x.Id.Equals(id), cancellationToken);
    }

    public async Task<TEntity> FindSingleAsync(Expression<Func<TEntity, bool>>? predicate = null,
        CancellationToken cancellationToken = default, params Expression<Func<TEntity, object>>[] includeProperties)
    {
        return await FindAll(null, includeProperties)
            .AsTracking()
            .SingleOrDefaultAsync(predicate, cancellationToken);
    }

    public void Add(TEntity entity)
    {
        _dbContext.Add(entity);
    }

    public void AddRange(IEnumerable<TEntity> entities)
    {
        _dbContext.AddRange(entities);
    }

    public void UpdateRange(IEnumerable<TEntity> entities)
    {
        _dbContext.UpdateRange(entities);
    }

    public void Remove(TEntity entity)
    {
        _dbContext.Set<TEntity>().Remove(entity);
    }

    public void RemoveMultiple(List<TEntity> entities)
    {
        _dbContext.Set<TEntity>().RemoveRange(entities);
    }

    public void Update(TEntity entity)
    {
        _dbContext.Set<TEntity>().Update(entity);
    }
}

================
File: BEAUTIFY_QUERY.PRESENTATION/APIs/Bookings/Apis.cs
================
using BEAUTIFY_QUERY.CONTRACT.Services.Booking;

namespace BEAUTIFY_QUERY.PRESENTATION.APIs.Bookings;
public class Apis : ApiEndpoint, ICarterModule
{
    private const string BaseUrl = "api/v{version:apiVersion}/bookings";

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        var gr1 = app.NewVersionedApi("Bookings")
            .MapGroup(BaseUrl).HasApiVersion(1);
        gr1.MapGet("", GetBookingPagedResult).RequireAuthorization();
        gr1.MapGet("appointments/total", GetTotalAppointment).RequireAuthorization().WithSummary("mm-yyyy");
        gr1.MapGet("appointments/{date}", GetBookingWithDate).RequireAuthorization();
        gr1.MapGet("{id:guid}", GetBookingDetailById).RequireAuthorization();
    }


    private static async Task<IResult> GetBookingDetailById(ISender sender, Guid id)
    {
        var result = await sender.Send(new Query.GetBookingDetailById(id));
        return result.IsSuccess ? Results.Ok(result) : HandlerFailure(result);
    }

    private static async Task<IResult> GetBookingPagedResult(ISender sender, string? searchTerm = null,
        string? sortColumn = null,
        string? sortOrder = null,
        int pageNumber = 1,
        int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetBookingPagedResult(searchTerm, sortColumn,
            SortOrderExtension.ConvertStringToSortOrder(sortOrder), pageNumber, pageSize));
        return result.IsSuccess ? Results.Ok(result) : HandlerFailure(result);
    }

    private static async Task<IResult> GetTotalAppointment(ISender sender, string Date)
    {
        var result = await sender.Send(new Query.GetTotalAppointment(Date));
        return result.IsSuccess ? Results.Ok(result) : HandlerFailure(result);
    }

    private static async Task<IResult> GetBookingWithDate(ISender sender, string date)
    {
        var result = await sender.Send(new Query.GetBookingWithDate(date));
        return result.IsSuccess ? Results.Ok(result) : HandlerFailure(result);
    }
}

================
File: BEAUTIFY_QUERY.PRESENTATION/APIs/Categories/CategoryApi.cs
================
using BEAUTIFY_QUERY.CONTRACT.Services.Categories;

namespace BEAUTIFY_QUERY.PRESENTATION.APIs.Categories;
public class CategoryApi : ApiEndpoint, ICarterModule
{
    private const string BaseUrl = "/api/v{version:apiVersion}/categories";

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        var gr1 = app.NewVersionedApi("Categories")
            .MapGroup(BaseUrl).HasApiVersion(1);

        gr1.MapGet(string.Empty, GetAllCategories);
        gr1.MapGet("{id}", GetCategoryId);
    }

    private static async Task<IResult> GetAllCategories(
        ISender sender,
        string? searchTerm = null,
        int pageIndex = 1,
        int pageSize = 10)
    {
        Result result;
        if (pageIndex != null && pageSize == null) result = await sender.Send(new Query.GetAllCategoriesQuery());
        else
            result = await sender.Send(
                new Query.GetAllCategoriesPagingQuery(searchTerm, pageIndex!, pageSize!));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetCategoryId(
        ISender sender, Guid id)
    {
        var result = await sender.Send(new Query.GetCategoryByIdQuery(id));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }
}

================
File: BEAUTIFY_QUERY.PRESENTATION/APIs/Clinics/ClinicApi.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Constrants;
using BEAUTIFY_QUERY.CONTRACT.Services.Clinics;

namespace BEAUTIFY_QUERY.PRESENTATION.APIs.Clinics;
public class ClinicApi : ApiEndpoint, ICarterModule
{
    private const string BaseUrl = "/api/v{version:apiVersion}/clinics";

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        var gr1 = app.NewVersionedApi("Clinics")
            .MapGroup(BaseUrl).HasApiVersion(1);

        gr1.MapGet(string.Empty, GetAllClinics);

        gr1.MapGet("{id}", GetClinicDetail);

        gr1.MapGet("{clinicId:guid}/employees", GetAllAccountOfEmployee);

        gr1.MapGet("{clinicId:guid}/employees/{employeeId:guid}", GetDetailAccountOfEmployee);

        gr1.MapGet("branches", GetClinicBranches)
            .RequireAuthorization(Constant.Policy.POLICY_CLINIC_ADMIN_AND_SYSTEM_STAFF)
            .WithName("Get Clinic Branches")
            .WithSummary("Get all branches for the current clinic admin");
        gr1.MapGet("branches/{id:guid}", GetClinicBranchById)
            .RequireAuthorization(Constant.Role.CLINIC_ADMIN);

        gr1.MapGet("sub-clinics/{id:guid}", GetSubClinicById)
            .RequireAuthorization(Constant.Role.CLINIC_STAFF)
            .WithName("Get Sub Clinic By Id")
            .WithSummary("Get a specific sub-clinic by ID")
            .WithDescription(
                "Retrieves details of a specific sub-clinic that belongs to the current clinic admin's main clinic");

        gr1.MapGet("application", GetAllApplyRequest)
            .RequireAuthorization();

        gr1.MapGet("application/clinic", GetAllApplyClinicRequest)
            .RequireAuthorization();

        gr1.MapGet("application/{id}", GetDetailApplyRequest)
            .RequireAuthorization();

        gr1.MapGet("application/{id}/clinic", GetDetailBranchApplyRequest)
            .RequireAuthorization();

        gr1.MapGet("application/me", GetMyApplyRequest)
            .RequireAuthorization();
    }

    private static async Task<IResult> GetSubClinicById(
        ISender sender,
        Guid id)
    {
        var result = await sender.Send(new Query.GetSubClinicByIdQuery(id));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetClinicBranchById(
        ISender sender,
        Guid id)
    {
        var result = await sender.Send(new Query.GetClinicByIdQuery(id));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetClinicBranches(ISender sender,
        HttpContext httpContext, Guid? id)
    {
        var role = httpContext.User.FindFirst(c => c.Type == "RoleName")?.Value!;
        var result = await sender.Send(new Query.GetClinicBranchesQuery(id, role));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetAllClinics(
        ISender sender,
        HttpContext httpContext,
        string? searchTerm = null,
        string? sortColumn = null,
        string? sortOrder = null,
        int pageIndex = 1,
        int pageSize = 10)
    {
        var role = httpContext.User.FindFirst(c => c.Type == "RoleName")?.Value;

        var result = await sender.Send(new Query.GetClinicsQuery(searchTerm, role,
            sortColumn, SortOrderExtension.ConvertStringToSortOrder(sortOrder),
            pageIndex, pageSize));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetClinicDetail(ISender sender, Guid id, string? searchTerm = null,
        string? sortColumn = null,
        string? sortOrder = null,
        int pageIndex = 1,
        int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetClinicDetailQuery(id, searchTerm,
            sortColumn, SortOrderExtension.ConvertStringToSortOrder(sortOrder),
            pageIndex, pageSize));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetAllApplyRequest(ISender sender, int pageIndex = 1, int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetAllApplyRequestQuery(pageIndex, pageSize));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetAllApplyClinicRequest(ISender sender,
        HttpContext httpContext, string? searchTerm = null,
        int pageIndex = 1, int pageSize = 10)
    {
        var clinicId = httpContext.User.FindFirst(c => c.Type == "ClinicId")?.Value;
        var result = await sender.Send(new Query.GetAllApplyBranchRequestQuery(
            clinicId == null ? null : new Guid(clinicId),
            searchTerm, pageIndex, pageSize));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetDetailApplyRequest(ISender sender, Guid id)
    {
        var result = await sender.Send(new Query.GetDetailApplyRequestQuery(id));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetDetailBranchApplyRequest(ISender sender, Guid id)
    {
        var result = await sender.Send(new Query.GetDetailBranchApplyRequestQuery(id));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetMyApplyRequest(ISender sender, HttpContext httpContext)
    {
        var clinicId = httpContext.User.FindFirst(c => c.Type == "ClinicId")?.Value!;
        var roleName = httpContext.User.FindFirst(c => c.Type == "RoleName")?.Value!;
        var result = await sender.Send(new Query.GetClinicMyQuery(new Guid(clinicId), roleName));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetAllAccountOfEmployee(ISender sender, Guid clinicId,
        Query.Roles? role, string? searchTerm = null,
        int pageIndex = 1, int pageSize = 10)
    {
        var result =
            await sender.Send(new Query.GetAllAccountOfEmployeeQuery(clinicId, role, searchTerm, pageIndex, pageSize));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetDetailAccountOfEmployee(ISender sender, Guid clinicId,
        Guid employeeId)
    {
        var result = await sender.Send(new Query.GetDetailAccountOfEmployeeQuery(clinicId, employeeId));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }
}

================
File: BEAUTIFY_QUERY.PRESENTATION/APIs/CustomerSchedules/Apis.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Constrants;
using BEAUTIFY_QUERY.CONTRACT.Services.CustomerSchedules;
using Microsoft.AspNetCore.Mvc;

namespace BEAUTIFY_QUERY.PRESENTATION.APIs.CustomerSchedules;
public class Apis : ApiEndpoint, ICarterModule
{
    private const string BaseUrl = "api/v{verison:apiVersion}/customer-schedules";

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        var gr1 = app.NewVersionedApi("CustomerSchedules").MapGroup(BaseUrl).HasApiVersion(1);
        gr1.MapGet("customer/{customerName}", StaffCheckInCustomerSchedule)
            .RequireAuthorization()
            .WithName("Staff Check In Customer Schedule")
            .WithSummary("Staff Check In Customer Schedule")
            .WithDescription("Check in customer schedule by staff");
        gr1.MapGet("clinic", GetAllCustomerSchedule)
            .RequireAuthorization(Constant.Role.CLINIC_STAFF)
            .WithName("Get All Customer Schedule")
            .WithSummary("Get All Customer Schedule")
            .WithDescription("Get all customer schedule");
        gr1.MapGet("{customerScheduleId:guid}", GetCustomerScheduleById)
            .RequireAuthorization()
            .WithName("Get Customer Schedule By Id")
            .WithSummary("Get Customer Schedule By Id")
            .WithDescription("Get customer schedule by id");
        gr1.MapGet("{customerScheduleId:guid}/next-schedule/availability",
                CheckIfNextCustomerScheduleIsNotScheduledYet)
            .RequireAuthorization(Constant.Role.CLINIC_STAFF)
            .WithName("Check Next Schedule Availability")
            .WithSummary("Check if next schedule is available")
            .WithDescription("Check if the next customer schedule is not scheduled yet");
        gr1.MapGet("{customerId:guid}/busy-time/{date}", GetAllCustomerBusyTime)
            .RequireAuthorization(Constant.Role.CUSTOMER);
    }


    private static async Task<IResult> GetAllCustomerBusyTime(
        ISender sender,
        [FromRoute] Guid customerId,
        [FromRoute] DateOnly date)
    {
        var result = await sender.Send(new Query.GetAllCustomerBusyTime(customerId, date));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> CheckIfNextCustomerScheduleIsNotScheduledYet(
        ISender sender,
        [FromRoute] Guid customerScheduleId)
    {
        var result = await sender.Send(
            new Query.CheckIfNextCustomerScheduleIsNotScheduledYet(customerScheduleId));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> StaffCheckInCustomerSchedule(ISender sender,
        [FromRoute] string customerName,
        [FromQuery] string customerPhone,
        [FromQuery] int pageIndex = 1,
        [FromQuery] int pageSize = 10)
    {
        var result = await sender.Send(
            new Query.StaffCheckInCustomerScheduleQuery(customerName, customerPhone, pageIndex, pageSize));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetAllCustomerSchedule(ISender sender,
        string SearchTerm = null,
        string? sortColumn = null,
        string? sortOrder = null,
        int pageIndex = 1,
        int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetAllCustomerSchedule(SearchTerm,
            sortColumn, SortOrderExtension.ConvertStringToSortOrder(sortOrder),
            pageIndex, pageSize));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetCustomerScheduleById(ISender sender,
        Guid customerScheduleId)
    {
        var result = await sender.Send(new Query.GetCustomerScheduleById(customerScheduleId));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }
}

================
File: BEAUTIFY_QUERY.PRESENTATION/APIs/Dashboard/DashboardApi.cs
================
using BEAUTIFY_QUERY.CONTRACT.Services.Dashboards;

namespace BEAUTIFY_QUERY.PRESENTATION.APIs.Dashboard;
public class DashboardApi : ApiEndpoint, ICarterModule
{
    private const string BaseUrl = "api/v{version:apiVersion}/dashboards";

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        var gr1 = app.NewVersionedApi("Dashboards")
            .MapGroup(BaseUrl)
            .HasApiVersion(1);

        gr1.MapGet("clinics", GetTotalInformation)
            .RequireAuthorization();

        gr1.MapGet("clinics/datetime", GetDaytimeInformation)
            .RequireAuthorization();

        gr1.MapGet("systems", GetSystemTotalInformation)
            .RequireAuthorization();

        gr1.MapGet("systems/datetime", GetSystemDaytimeInformation)
            .RequireAuthorization();
    }

    private static async Task<IResult> GetTotalInformation(
        ISender sender,
        HttpContext httpContext)
    {
        var clinicId = httpContext.User.FindFirst(c => c.Type == "ClinicId")?.Value!;
        var roleName = httpContext.User.FindFirst(c => c.Type == "RoleName")?.Value!;
        var result = await sender.Send(new Query.GetTotalInformationQuery(roleName, new Guid(clinicId)));
        return result.IsSuccess ? Results.Ok(result) : HandlerFailure(result);
    }

    private static async Task<IResult> GetDaytimeInformation(
        ISender sender,
        HttpContext httpContext,
        DateOnly? startDate,
        DateOnly? endDate,
        bool? isDisplayWeek,
        DateOnly? date)
    {
        var clinicId = httpContext.User.FindFirst(c => c.Type == "ClinicId")?.Value!;
        var roleName = httpContext.User.FindFirst(c => c.Type == "RoleName")?.Value!;
        var result = await sender.Send(new Query.GetDaytimeInformationQuery(
            roleName,
            new Guid(clinicId),
            startDate,
            endDate,
            isDisplayWeek,
            date));
        return result.IsSuccess ? Results.Ok(result) : HandlerFailure(result);
    }

    private static async Task<IResult> GetSystemTotalInformation(
        ISender sender,
        HttpContext httpContext)
    {
        var roleName = httpContext.User.FindFirst(c => c.Type == "RoleName")?.Value!;
        var result = await sender.Send(new Query.GetSystemTotalInformationQuery(roleName));
        return result.IsSuccess ? Results.Ok(result) : HandlerFailure(result);
    }

    private static async Task<IResult> GetSystemDaytimeInformation(
        ISender sender,
        HttpContext httpContext,
        DateOnly? startDate,
        DateOnly? endDate,
        bool? isDisplayWeek,
        DateOnly? date)
    {
        var roleName = httpContext.User.FindFirst(c => c.Type == "RoleName")?.Value!;
        var result = await sender.Send(new Query.GetSystemDaytimeInformationQuery(roleName,
            startDate,
            endDate,
            isDisplayWeek,
            date));
        return result.IsSuccess ? Results.Ok(result) : HandlerFailure(result);
    }
}

================
File: BEAUTIFY_QUERY.PRESENTATION/APIs/DoctorCertificates/DoctorCertificateApi.cs
================
using BEAUTIFY_QUERY.CONTRACT.Services.DoctorCertificates;

namespace BEAUTIFY_QUERY.PRESENTATION.APIs.DoctorCertificates;
public class DoctorCertificateApi : ApiEndpoint, ICarterModule
{
    private const string BaseUrl = "/api/v{version:apiVersion}/doctor-certificates";

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        var gr1 = app.NewVersionedApi("Doctor Certificates")
            .MapGroup(BaseUrl)
            .HasApiVersion(1);

        // Get all certificates for a specific doctor
        gr1.MapGet("doctors/{doctorId:guid}/certificates", GetCertificatesByDoctorId);

        // Get a specific certificate by its ID
        gr1.MapGet("{id:guid}", GetCertificateById);

        // Get all certificates (with filtering, sorting, and pagination)
        gr1.MapGet(string.Empty, GetAllCertificates);
    }

    private static async Task<IResult> GetCertificatesByDoctorId(
        ISender sender,
        Guid doctorId)
    {
        var result = await sender.Send(new Query.GetDoctorCertificateByDoctorId(doctorId));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetCertificateById(
        ISender sender,
        Guid id)
    {
        var result = await sender.Send(new Query.GetDoctorCertificateById(id));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetAllCertificates(
        ISender sender,
        string? searchTerm = null,
        string? sortColumn = null,
        string? sortOrder = null,
        int pageNumber = 1,
        int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetAllDoctorCertificates(
            searchTerm,
            sortColumn,
            SortOrderExtension.ConvertStringToSortOrder(sortOrder),
            pageNumber,
            pageSize
        ));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }
}

================
File: BEAUTIFY_QUERY.PRESENTATION/APIs/OrderDetails/Apis.cs
================
using BEAUTIFY_QUERY.CONTRACT.Services.OrderDetails;

namespace BEAUTIFY_QUERY.PRESENTATION.APIs.OrderDetails;
public class Apis : ApiEndpoint, ICarterModule
{
    private const string BaseUrl = "/api/v{version:apiVersion}/order-details";

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        var gr1 = app.NewVersionedApi("OrderDetails")
            .MapGroup(BaseUrl).HasApiVersion(1);
        gr1.MapGet("{orderId:guid}", GetOrderDetails);
    }

    private static async Task<IResult> GetOrderDetails(ISender sender,
        Guid orderId)
    {
        var result = await sender.Send(new Query.GetOrderDetailsByOrderIdQuery(orderId));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }
}

================
File: BEAUTIFY_QUERY.PRESENTATION/APIs/Orders/Apis.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Constrants;
using BEAUTIFY_QUERY.CONTRACT.Services.Orders;

namespace BEAUTIFY_QUERY.PRESENTATION.APIs.Orders;
public class Apis : ApiEndpoint, ICarterModule
{
    private const string BaseUrl = "api/v{version:apiVersion}/orders";

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        var gr1 = app.NewVersionedApi("Orders")
            .MapGroup(BaseUrl).HasApiVersion(1);
        gr1.MapGet(string.Empty, GetOrder).RequireAuthorization();
        gr1.MapGet("{id}", GetOrderById);
        gr1.MapGet("clinic", GetOrderByClinicId).RequireAuthorization(Constant.Role.CLINIC_STAFF);
        gr1.MapGet("clinic/branches", GetClinicOrderBranches)
            .RequireAuthorization(Constant.Role.CLINIC_ADMIN)
            .WithName("Get Clinic Order Branches")
            .WithSummary("Get all orders from clinic branches")
            .WithDescription("Retrieves orders from all branches of the parent clinic. Requires Clinic_Admin role.");
    }

    private static async Task<IResult> GetOrderByClinicId(ISender sender, string? searchTerm = null,
        string? sortColumn = null,
        string? sortOrder = null,
        int pageIndex = 1,
        int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetOrdersByClinicId(searchTerm,
            sortColumn, SortOrderExtension.ConvertStringToSortOrder(sortOrder),
            pageIndex, pageSize));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetOrder(ISender sender, string? searchTerm = null, string? sortColumn = null,
        string? sortOrder = null, int pageIndex = 1, int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetOrdersByCustomerId(searchTerm, sortColumn,
            SortOrderExtension.ConvertStringToSortOrder(sortOrder), pageIndex, pageSize));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetOrderById(ISender sender, Guid id)
    {
        var result = await sender.Send(new Query.GetOrderById(id));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetClinicOrderBranches(ISender sender, string? searchTerm = null,
        string? sortColumn = null,
        string? sortOrder = null,
        int pageIndex = 1,
        int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetClinicOrderBranchesQuery(searchTerm,
            sortColumn, SortOrderExtension.ConvertStringToSortOrder(sortOrder),
            pageIndex, pageSize));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }
}

================
File: BEAUTIFY_QUERY.PRESENTATION/APIs/Services/ServiceApi.cs
================
using Query = BEAUTIFY_QUERY.CONTRACT.Services.Services.Query;

namespace BEAUTIFY_QUERY.PRESENTATION.APIs.Services;
public class ServiceApi : ApiEndpoint, ICarterModule
{
    private const string BaseUrl = "/api/v{version:apiVersion}/services";

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        var gr1 = app.NewVersionedApi("Services")
            .MapGroup(BaseUrl)
            .HasApiVersion(1);

        gr1.MapGet(string.Empty, GetAllServices);
        gr1.MapGet("{id}", GetServicesById);
        gr1.MapGet("{id}/doctors", GetDoctorServicesById);
        //gr1.MapGet("clinic", GetServicesByClinicId);
        gr1.MapGet("clinics/{clinicId:guid}", GetServicesByClinicIdForCustomer);
        gr1.MapGet("categories/{categoryId:guid}", GetServicesByCategoryId);
        
        var gr2 = app.NewVersionedApi("Services")
            .MapGroup(BaseUrl)
            .HasApiVersion(2);
        
        gr2.MapGet("{id}/doctors", GetDoctorServicesByIdV2);
    }
    



    private static async Task<IResult> GetServicesByCategoryId(ISender sender, Guid categoryId)
    {
        var result = await sender.Send(new Query.GetServiceByCategoryIdQuery(categoryId));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetServicesByClinicIdForCustomer(
        ISender sender, Guid clinicId)
    {
        var result = await sender.Send(new Query.GetServiceByClinicIdQuery(clinicId));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetAllServices(
        ISender sender, HttpContext httpContext, string? searchTerm = null,
        string? sortColumn = null,
        string? sortOrder = null,
        int pageIndex = 1,
        int pageSize = 10)
    {
        var mainClinicId = httpContext.User.FindFirst(c => c.Type == "ClinicId")?.Value;

        var result = await sender.Send(new Query.GetClinicServicesQuery(searchTerm,
            sortColumn, SortOrderExtension.ConvertStringToSortOrder(sortOrder),
            pageIndex, pageSize, !string.IsNullOrEmpty(mainClinicId) ? new Guid(mainClinicId) : null));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetServicesById(
        ISender sender, HttpContext httpContext, Guid id)
    {
        var mainClinicId = httpContext.User.FindFirst(c => c.Type == "ClinicId")?.Value;

        var result = await sender.Send(new Query.GetClinicServicesByIdQuery(id,
            !string.IsNullOrEmpty(mainClinicId) ? new Guid(mainClinicId) : null));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }
    
    private static async Task<IResult> GetDoctorServicesById(
        ISender sender, Guid id, int pageIndex = 1, int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetDoctorClinicServicesByIdQuery(id, pageIndex, pageSize));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }
    
    private static async Task<IResult> GetDoctorServicesByIdV2(
        ISender sender, Guid id, int pageIndex = 1, int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetDoctorClinicServicesByIdQueryV2(id));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetServicesByClinicId(
        ISender sender, int pageIndex = 1, int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetAllServiceInGetClinicByIdQuery(pageIndex, pageSize));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }
}

================
File: BEAUTIFY_QUERY.PRESENTATION/APIs/ShiftConfigs/ShiftConfigApi.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Constrants;
using BEAUTIFY_QUERY.CONTRACT.Services.ShiftConfigs;

namespace BEAUTIFY_QUERY.PRESENTATION.APIs.ShiftConfigs;

public class ShiftConfigApi: ApiEndpoint, ICarterModule
{
    private const string BaseUrl = "/api/v{version:apiVersion}/shiftConfigs";

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        var gr1 = app.NewVersionedApi("Shift Configs")
            .MapGroup(BaseUrl).HasApiVersion(1);

        gr1.MapGet("", GetAllShiftConfig)
            .RequireAuthorization(Constant.Policy.POLICY_CLINIC_ADMIN_AND_CLINIC_STAFF);
    }
    
    private static async Task<IResult> GetAllShiftConfig(ISender sender,
        HttpContext httpContext,
        int pageIndex = 1,
        int pageSize = 10)
    {
        var clinicId = httpContext.User.FindFirst(c => c.Type == "ClinicId")?.Value!;
        var role = httpContext.User.FindFirst(c => c.Type == "RoleName")?.Value!;
        
        var result = await sender.Send(new Query.GetShiftConfigQuery(new Guid(clinicId), role,
            pageIndex, pageSize));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

}

================
File: BEAUTIFY_QUERY.PRESENTATION/APIs/Subscriptions/SubscriptionApi.cs
================
using BEAUTIFY_QUERY.CONTRACT.Services.Subscriptions;

namespace BEAUTIFY_QUERY.PRESENTATION.APIs.Subscriptions;
public class SubscriptionApi : ApiEndpoint, ICarterModule
{
    private const string BaseUrl = "/api/v{version:apiVersion}/subscriptions";

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        var group1 = app.NewVersionedApi("Subscriptions")
            .MapGroup(BaseUrl).HasApiVersion(1);

        group1.MapGet(string.Empty, GetSubscriptions);
        group1.MapGet("{id:guid}", GetSubscriptionById);
    }

    private static async Task<IResult> GetSubscriptions(ISender sender, string? searchTerm = null,
        string? sortColumn = null,
        string? sortOrder = null,
        int pageIndex = 1,
        int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetSubscription(searchTerm,
            sortColumn, SortOrderExtension.ConvertStringToSortOrder(sortOrder),
            pageIndex, pageSize));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetSubscriptionById(ISender sender, Guid id)
    {
        var result = await sender.Send(new Query.GetSubscriptionById(id));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }
}

================
File: BEAUTIFY_QUERY.PRESENTATION/APIs/SurveyQuestions/Apis.cs
================
using BEAUTIFY_QUERY.CONTRACT.Services.SurveyQuestions;

namespace BEAUTIFY_QUERY.PRESENTATION.APIs.SurveyQuestions;
public class Apis : ApiEndpoint, ICarterModule
{
    private const string BaseUrl = "/api/v{version:apiVersion}/survey-questions";

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        var gr1 = app.NewVersionedApi("SurveyQuestions").MapGroup(BaseUrl).HasApiVersion(1);
        gr1.MapGet("", GetSurveyQuestionBySurveyId);
    }

    private static async Task<IResult> GetSurveyQuestionBySurveyId(ISender sender, Guid surveyId, int pageIndex = 1,
        int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetSurveyQuestionBySurveyId(surveyId, pageIndex, pageSize));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }
}

================
File: BEAUTIFY_QUERY.PRESENTATION/APIs/Surveys/Apis.cs
================
using BEAUTIFY_QUERY.CONTRACT.Services.Surveys;

namespace BEAUTIFY_QUERY.PRESENTATION.APIs.Surveys;
public class Apis : ApiEndpoint, ICarterModule
{
    private const string BaseUrl = "/api/v{version:apiVersion}/surveys";

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        var gr1 = app.NewVersionedApi("Surveys").MapGroup(BaseUrl).HasApiVersion(1);
        gr1.MapGet("", GetSurvey);
    }

    private static async Task<IResult> GetSurvey(ISender sender, string? searchTerm = null,
        string? sortColumn = null,
        string? sortOrder = null,
        int pageIndex = 1,
        int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetSurvey(searchTerm,
            sortColumn, SortOrderExtension.ConvertStringToSortOrder(sortOrder),
            pageIndex, pageSize));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }
}

================
File: BEAUTIFY_QUERY.PRESENTATION/APIs/Users/Apis.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Constrants;
using BEAUTIFY_QUERY.CONTRACT.Services.Users;

namespace BEAUTIFY_QUERY.PRESENTATION.APIs.Users;
public class Apis : ApiEndpoint, ICarterModule
{
    private const string BaseUrl = "api/v{version:apiVersion}/users";

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        var gr1 = app.NewVersionedApi("Users")
            .MapGroup(BaseUrl).HasApiVersion(1);
        gr1.MapGet("get-user-by-phone-or-email/{searchTerm}", GetUserByPhoneOrEmail);

        gr1.MapGet("information", GetUserInformation)
            .RequireAuthorization(Constant.Policy.POLICY_DOCTOR_AND_CUSTOMER);
        gr1.MapGet("{userId:guid}/balance", GetCustomerCurrentBalance).RequireAuthorization(Constant.Role.CLINIC_STAFF);
    }

    private static async Task<IResult> GetCustomerCurrentBalance(ISender sender, Guid userId)
    {
        var result = await sender.Send(new Query.GetCustomerCurrentBalance(userId));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetUserByPhoneOrEmail(ISender sender, string searchTerm)
    {
        var result = await sender.Send(new Query.GetUserByPhoneOrEmail(searchTerm));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetUserInformation(ISender sender)
    {
        var result = await sender.Send(new Query.GetUserInformation());
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }
}

================
File: BEAUTIFY_QUERY.PRESENTATION/APIs/WalletTransactions/Apis.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Constrants;
using BEAUTIFY_QUERY.CONTRACT.Services.WalletTransactions;

namespace BEAUTIFY_QUERY.PRESENTATION.APIs.WalletTransactions;
public class Apis : ApiEndpoint, ICarterModule
{
    private const string BaseUrl = "api/v{version:apiVersion}/wallet-transactions";

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        var gr1 = app.NewVersionedApi("WalletTransactions")
            .MapGroup(BaseUrl).HasApiVersion(1);

        // 1. Endpoint for a clinic to get its own transactions
        gr1.MapGet("clinic", GetClinicWalletTransactions)
            .RequireAuthorization(Constant.Role.CLINIC_STAFF)
            .WithName("GetClinicWalletTransactions")
            .WithSummary("Get wallet transactions for the current clinic")
            .WithDescription(
                "Retrieves wallet transactions for the authenticated clinic with filtering, sorting, and pagination options");

        // 2. Endpoint for a parent clinic to get transactions of its sub-clinics
        gr1.MapGet("sub-clinics", GetSubClinicWalletTransactions)
            .RequireAuthorization(Constant.Role.CLINIC_ADMIN)
            .WithName("GetSubClinicWalletTransactions")
            .WithSummary("Get wallet transactions for all sub-clinics of a parent clinic")
            .WithDescription(
                "Retrieves wallet transactions for all sub-clinics of the specified parent clinic with filtering, sorting, and pagination options");

        // 3. Endpoint for admin to get all clinic transactions
        gr1.MapGet("admin/all-clinics", GetAllClinicWalletTransactions)
            .RequireAuthorization(Constant.Role.SYSTEM_ADMIN)
            .WithName("GetAllClinicWalletTransactions")
            .WithSummary("Get wallet transactions for all clinics (admin only)")
            .WithDescription(
                "Retrieves wallet transactions for all clinics with filtering, sorting, and pagination options. Requires admin privileges.");

        // 4. Endpoint for customer to get their own transactions
        gr1.MapGet("customer", CustomerGetAllWalletTransactions)
            .RequireAuthorization(Constant.Role.CUSTOMER)
            .WithName("CustomerGetAllWalletTransactions")
            .WithSummary("Get wallet transactions for the current customer")
            .WithDescription(
                "Retrieves wallet transactions for the authenticated customer with filtering, sorting, and pagination options");

        // 5. Endpoint to get wallet history for a specific clinic by ID
        gr1.MapGet("clinics/{clinicId:guid}", GetWalletHistoryByClinicId)
            .RequireAuthorization(Constant.Role.CLINIC_ADMIN, Constant.Role.SYSTEM_ADMIN)
            .WithName("GetWalletHistoryByClinicId")
            .WithSummary("Get wallet history for a specific clinic by ID")
            .WithDescription(
                "Retrieves wallet transactions for a specific clinic. Clinic admins can only access their own clinic or sub-clinics. System admins can access any clinic.");
    }

    private static async Task<IResult> GetWalletHistoryByClinicId(
        ISender sender,
        Guid clinicId,
        string? searchTerm = null,
        string? sortColumn = null,
        string? sortOrder = null,
        int pageIndex = 1,
        int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetWalletHistoryByClinicId(
            clinicId,
            searchTerm,
            sortColumn,
            SortOrderExtension.ConvertStringToSortOrder(sortOrder),
            pageIndex,
            pageSize));

        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetClinicWalletTransactions(
        ISender sender,
        string? searchTerm = null,
        string? sortColumn = null,
        string? sortOrder = null,
        int pageIndex = 1,
        int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetClinicWalletTransactions(
            searchTerm,
            sortColumn,
            SortOrderExtension.ConvertStringToSortOrder(sortOrder),
            pageIndex,
            pageSize));

        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetSubClinicWalletTransactions(
        ISender sender,
        string? searchTerm = null,
        string? sortColumn = null,
        string? sortOrder = null,
        int pageIndex = 1,
        int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetSubClinicWalletTransactions(
            searchTerm,
            sortColumn,
            SortOrderExtension.ConvertStringToSortOrder(sortOrder),
            pageIndex,
            pageSize));

        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> CustomerGetAllWalletTransactions(
        ISender sender,
        string? searchTerm = null,
        string? sortColumn = null,
        string? sortOrder = null,
        int pageIndex = 1,
        int pageSize = 10)
    {
        var result = await sender.Send(new Query.CustomerGetAllWalletTransactions(
            searchTerm,
            sortColumn,
            SortOrderExtension.ConvertStringToSortOrder(sortOrder),
            pageIndex,
            pageSize
        ));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetAllClinicWalletTransactions(
        ISender sender,
        string? searchTerm = null,
        string? sortColumn = null,
        string? sortOrder = null,
        int pageIndex = 1,
        int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetAllClinicWalletTransactions(
            searchTerm,
            sortColumn,
            SortOrderExtension.ConvertStringToSortOrder(sortOrder),
            pageIndex,
            pageSize));

        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }
}

================
File: BEAUTIFY_QUERY.PRESENTATION/APIs/WorkingSchedules/WorkingScheduleApi.cs
================
using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.DOMAIN.Constrants;
using BEAUTIFY_QUERY.CONTRACT.Services.WorkingSchedules;
using Microsoft.AspNetCore.Mvc;

namespace BEAUTIFY_QUERY.PRESENTATION.APIs.WorkingSchedules;
public class WorkingScheduleApi : ApiEndpoint, ICarterModule
{
    private const string BaseUrl = "/api/v{version:apiVersion}/working-schedules";

    public void AddRoutes(IEndpointRouteBuilder app)
    {
        var gr1 = app.NewVersionedApi("Working Schedules").MapGroup(BaseUrl).HasApiVersion(1);
        //  gr1.MapGet(string.Empty, GetWorkingSchedules)
        //      .WithSummary("Search theo Date : Date1 to Date2 or Time : Time1 to Time2|| search by DoctorName");
        //   gr1.MapGet("doctors/busy-times", GetDoctorBusyTimeInADay)
        //  .WithSummary("Get doctor's busy time slots for a specific day");
        gr1.MapGet("doctors/available-times", GetDoctorAvailableTimeSlots)
            .WithSummary("Get doctor's available time slots for booking").RequireAuthorization();
        gr1.MapGet("doctors/", GetDoctorScheduleByIdV2).RequireAuthorization();
        gr1.MapGet("doctors/monthly-count", GetWorkingSchedulesEachDayInMonth)
            .WithSummary("Get doctor's busy time slots for a specific month")
            .RequireAuthorization(Constant.Role.DOCTOR);
        gr1.MapGet("doctors/daily-count", GetWorkingScheduleDaily)
            .WithSummary("Get doctor's busy time slots for a specific day")
            .RequireAuthorization(Constant.Role.DOCTOR);

        gr1.MapGet("doctors/{id:guid}", GetWorkingScheduleById)
            .WithSummary("Get doctor's busy time slots for a specific day")
            .RequireAuthorization(Constant.Role.DOCTOR);

        gr1.MapGet("clinics", GetWorkingSchedulesByClinicId)
            .WithSummary("Get working schedules by clinic ID")
            .RequireAuthorization(Constant.Role.CLINIC_STAFF);
        gr1.MapGet("{clinicId:guid}/unregistered", GetUnregisteredWorkingSchedule)
            .WithSummary("Get unregistered working schedules")
            .RequireAuthorization(Constant.Role.DOCTOR);
        gr1.MapGet("shift-groups/{shiftGroupId:guid}", GetSchedulesByShiftGroupId)
            .WithSummary("Get working schedules by shift group ID")
            .RequireAuthorization(Constant.Role.CLINIC_STAFF);
        gr1.MapGet("{clinicId:guid}/working-hours", GetClinicWorkingHours)
            .WithSummary("Get clinic working hours")
            .RequireAuthorization();
    }

    #region GetDoctorBusyTimeInADay

    private static async Task<IResult> GetDoctorBusyTimeInADay(
        ISender sender,
        [FromQuery] Guid doctorId,
        [FromQuery] Guid clinicId,
        [FromQuery] DateOnly date)
    {
        var query = new Query.GetAllDoctorFreeTime(doctorId, clinicId, date);
        var result = await sender.Send(query);
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    #endregion

    private static async Task<IResult> GetClinicWorkingHours(
        ISender sender,
        [FromRoute] Guid clinicId)
    {
        var result = await sender.Send(new Query.GetClinicWorkingHours(clinicId));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetDoctorAvailableTimeSlots(
        ISender sender,
        [FromQuery] Guid? doctorId,
        [FromQuery] Guid serviceIdOrCustomerScheduleId,
        [FromQuery] Guid? clinicId,
        [FromQuery] bool isCustomerSchedule,
        [FromQuery] DateOnly date)
    {
        var query = new Query.GetDoctorAvailableTimeSlots(serviceIdOrCustomerScheduleId, clinicId, isCustomerSchedule,
            doctorId,
            date);
        var result = await sender.Send(query);
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetUnregisteredWorkingSchedule(ISender sender,
        Guid clinicId,
        string? searchTerm = null,
        string? sortColumn = null,
        string? sortOrder = null,
        int pageIndex = 1,
        int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetUnregisteredWorkingSchedules(clinicId, searchTerm,
            sortColumn, SortOrderExtension.ConvertStringToSortOrder(sortOrder),
            pageIndex, pageSize));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetSchedulesByShiftGroupId(
        ISender sender,
        [FromRoute] Guid shiftGroupId,
        string? searchTerm = null,
        string? sortColumn = null,
        string? sortOrder = null,
        int pageNumber = 1,
        int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetSchedulesByShiftGroupId(
            shiftGroupId,
            searchTerm,
            sortColumn,
            SortOrderExtension.ConvertStringToSortOrder(sortOrder),
            pageNumber,
            pageSize));

        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetWorkingSchedulesByClinicId(
        ISender sender,
        string? searchTerm = null,
        string? sortColumn = null,
        string? sortOrder = null,
        int pageIndex = 1,
        int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetWorkingScheduleByClinicId(searchTerm,
            sortColumn, SortOrderExtension.ConvertStringToSortOrder(sortOrder),
            pageIndex, pageSize));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetWorkingSchedulesEachDayInMonth(
        ISender sender,
        [FromQuery] DateOnly date)
    {
        var result = await sender.Send(new Query.GetWorkingScheduleEachDayInMonth(date));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetWorkingScheduleDaily(
        ISender sender,
        [FromQuery] DateOnly date)
    {
        var result = await sender.Send(new Query.GetWorkingScheduleDaily(date));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetDoctorScheduleByIdV2(ISender sender, string searchTerm = null,
        string? sortColumn = null,
        string? sortOrder = null,
        int pageNumber = 1,
        int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetWorkingScheduleOfDoctorId(searchTerm,
            sortColumn, SortOrderExtension.ConvertStringToSortOrder(sortOrder),
            pageNumber, pageSize));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    #region GetWorkingSchedules

    private static async Task<IResult> GetWorkingScheduleById(
        ISender sender,
        [FromRoute] Guid id)
    {
        var result = await sender.Send(new Query.GetWorkingScheduleDetail(id));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    private static async Task<IResult> GetWorkingSchedules(ISender sender, string? searchTerm = null,
        string? sortColumn = null,
        string? sortOrder = null,
        int pageIndex = 1,
        int pageSize = 10)
    {
        var result = await sender.Send(new Query.GetWorkingSchedule(searchTerm,
            sortColumn, SortOrderExtension.ConvertStringToSortOrder(sortOrder),
            pageIndex, pageSize));
        return result.IsFailure ? HandlerFailure(result) : Results.Ok(result);
    }

    #endregion
}

================
File: BEAUTIFY_QUERY.PRESENTATION/BEAUTIFY_QUERY.PRESENTATION.csproj
================
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="Asp.Versioning.Mvc.ApiExplorer" Version="8.1.0"/>
        <PackageReference Include="BEAUTIFY_PACKAGES.SHARE" Version="1.12.6"/>
        <PackageReference Include="Carter" Version="7.2.0"/>
    </ItemGroup>

    <ItemGroup>
        <ProjectReference Include="..\BEAUTIFY_QUERY.CONTRACT\BEAUTIFY_QUERY.CONTRACT.csproj"/>
    </ItemGroup>

    <ItemGroup>
        <PackageVersion Update="BEAUTIFY_PACKAGES.SHARE" Version="1.6.0"/>
    </ItemGroup>

</Project>

================
File: BEAUTIFY_QUERY.PRESENTATION/Constrants/RoleNames.cs
================
namespace BEAUTIFY_QUERY.PRESENTATION.Constrants;
public class RoleNames
{
    public const string Customer = nameof(Customer);
    public const string Doctor = nameof(Doctor);
    public const string ClinicManager = nameof(ClinicManager);
    public const string ClinicStaff = nameof(ClinicStaff);
    public const string Admin = nameof(Admin);
}

================
File: BEAUTIFY_QUERY.PRESENTATION/GlobalUsings.cs
================
// Global using directives

global using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.PRESENTATION.Abstractions;
global using Carter;
global using Microsoft.AspNetCore.Builder;
global using Microsoft.AspNetCore.Routing;
global using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Abstractions.Shared;
global using MediatR;
global using BEAUTIFY_PACKAGES.BEAUTIFY_PACKAGES.CONTRACT.Extensions;
global using Microsoft.AspNetCore.Http;

================
File: BEAUTIFY_QUERY.sln
================
Microsoft Visual Studio Solution File, Format Version 12.00
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BEAUTIFY_QUERY.API", "BEAUTIFY_QUERY.API\BEAUTIFY_QUERY.API.csproj", "{73285577-2142-4FF1-B32D-206AFE6B4761}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BEAUTIFY_QUERY.APPLICATION", "BEAUTIFY_QUERY.APPLICATION\BEAUTIFY_QUERY.APPLICATION.csproj", "{C88FE0F2-8430-4D88-B6F8-6D70F90122D6}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BEAUTIFY_QUERY.CONTRACT", "BEAUTIFY_QUERY.CONTRACT\BEAUTIFY_QUERY.CONTRACT.csproj", "{1C69CDFD-1B4F-43BA-89FC-7185299A85BA}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BEAUTIFY_QUERY.DOMAIN", "BEAUTIFY_QUERY.DOMAIN\BEAUTIFY_QUERY.DOMAIN.csproj", "{9E540554-7B89-4159-BC7B-9ED8E9E73A18}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BEAUTIFY_QUERY.PERSISTENCE", "BEAUTIFY_QUERY.PERSISTENCE\BEAUTIFY_QUERY.PERSISTENCE.csproj", "{D851B1FD-EEF1-4956-BD6F-BFC0BCE2C93F}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BEAUTIFY_QUERY.PRESENTATION", "BEAUTIFY_QUERY.PRESENTATION\BEAUTIFY_QUERY.PRESENTATION.csproj", "{BD21FED1-D43D-43FC-8CF5-E3E1C83F9A3A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BEAUTIFY_QUERY.INFRASTRUCTURE", "BEAUTIFY_QUERY.INFRASTRUCTURE\BEAUTIFY_QUERY.INFRASTRUCTURE.csproj", "{27F29923-2155-483E-800C-55375A80643F}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "BEAUTIFY_QUERY.APPLICATION.Tests", "BEAUTIFY_QUERY.APPLICATION.Tests\BEAUTIFY_QUERY.APPLICATION.Tests.csproj", "{C921C86F-33FE-41B5-B25B-8B08B516501A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{73285577-2142-4FF1-B32D-206AFE6B4761}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{73285577-2142-4FF1-B32D-206AFE6B4761}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{73285577-2142-4FF1-B32D-206AFE6B4761}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{73285577-2142-4FF1-B32D-206AFE6B4761}.Release|Any CPU.Build.0 = Release|Any CPU
		{C88FE0F2-8430-4D88-B6F8-6D70F90122D6}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C88FE0F2-8430-4D88-B6F8-6D70F90122D6}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C88FE0F2-8430-4D88-B6F8-6D70F90122D6}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C88FE0F2-8430-4D88-B6F8-6D70F90122D6}.Release|Any CPU.Build.0 = Release|Any CPU
		{1C69CDFD-1B4F-43BA-89FC-7185299A85BA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{1C69CDFD-1B4F-43BA-89FC-7185299A85BA}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{1C69CDFD-1B4F-43BA-89FC-7185299A85BA}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{1C69CDFD-1B4F-43BA-89FC-7185299A85BA}.Release|Any CPU.Build.0 = Release|Any CPU
		{9E540554-7B89-4159-BC7B-9ED8E9E73A18}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9E540554-7B89-4159-BC7B-9ED8E9E73A18}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9E540554-7B89-4159-BC7B-9ED8E9E73A18}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9E540554-7B89-4159-BC7B-9ED8E9E73A18}.Release|Any CPU.Build.0 = Release|Any CPU
		{D851B1FD-EEF1-4956-BD6F-BFC0BCE2C93F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{D851B1FD-EEF1-4956-BD6F-BFC0BCE2C93F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{D851B1FD-EEF1-4956-BD6F-BFC0BCE2C93F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{D851B1FD-EEF1-4956-BD6F-BFC0BCE2C93F}.Release|Any CPU.Build.0 = Release|Any CPU
		{BD21FED1-D43D-43FC-8CF5-E3E1C83F9A3A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BD21FED1-D43D-43FC-8CF5-E3E1C83F9A3A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BD21FED1-D43D-43FC-8CF5-E3E1C83F9A3A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BD21FED1-D43D-43FC-8CF5-E3E1C83F9A3A}.Release|Any CPU.Build.0 = Release|Any CPU
		{27F29923-2155-483E-800C-55375A80643F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{27F29923-2155-483E-800C-55375A80643F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{27F29923-2155-483E-800C-55375A80643F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{27F29923-2155-483E-800C-55375A80643F}.Release|Any CPU.Build.0 = Release|Any CPU
		{C921C86F-33FE-41B5-B25B-8B08B516501A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C921C86F-33FE-41B5-B25B-8B08B516501A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C921C86F-33FE-41B5-B25B-8B08B516501A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C921C86F-33FE-41B5-B25B-8B08B516501A}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
EndGlobal

================
File: BEAUTIFY_QUERY.sln.DotSettings
================
<wpf:ResourceDictionary xml:space="preserve" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:s="clr-namespace:System;assembly=mscorlib" xmlns:ss="urn:shemas-jetbrains-com:settings-storage-xaml" xmlns:wpf="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
	<s:Boolean x:Key="/Default/CodeEditing/SuppressNullableWarningFix/Enabled/@EntryValue">False</s:Boolean></wpf:ResourceDictionary>

================
File: README.md
================
Tan 1 cu cu 1 tan...
